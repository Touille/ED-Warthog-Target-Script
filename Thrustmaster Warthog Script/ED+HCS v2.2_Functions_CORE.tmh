//	Copyright (C) 2017 Thomas Duployez (CMDR Touille)
//	V2.2.03.2b	2017/01/14
//	Distributed freely under the MIT License.
//	
//	Permission is hereby granted, free of charge, to any person obtaining a copy
//	of this software and associated documentation files (the "Software"), to deal
//	in the Software without restriction, including without limitation the rights
//	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//	copies of the Software, and to permit persons to whom the Software is
//	furnished to do so, subject to the following conditions:
//	
//	The above copyright notice and this permission notice shall be included in all
//	copies or substantial portions of the Software.
//	
//	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//	SOFTWARE.
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
//	FUNCTIONS																																					//
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//		
	
	//FUNCTION FPS & CONNECTION STATUS
	int initFPSCONNECTION(){
		ActKey(KEYON+PULSE+ShowFramerate);
		ActKey(KEYON+PULSE+ShowConnectionStatus);
		if(DebugMode)printf("FPS & CONNECTION STATUS\x0a");
	}
	
	//FUNCTION: Head Center
	int initHeadCenter(){
		if(HMD){ActKey(KEYON+PULSE+HMDCenter); if(DebugMode)printf("HMD Center\x0a");}
		else if(TrackIR){ActKey(KEYON+PULSE+TrackIRCenter); if(DebugMode)printf("TrackIR Center\x0a");}
		else{ActKey(KEYON+PULSE+UIFocus); if(DebugMode)printf("UI Focus\x0a");}
	}
	
	//FUNCTION: Voice PTT
	int initVoicePTT(){
		if(sPTTState)vPTT = InternalVoiceCommsPTT;	//External Mic
		else if(!sPTTState)vPTT = ExternalVoiceCommsPTT;	//Internal Mic
		if(Throttle[MSP]){
			vVoicePTT=!vVoicePTT;	//reverse the flag status
			if(sPTTMode){	//TOGGLE
				vVoice=!vVoice;	//reverse the flag status
				ActKey(KEYON+PULSE+vPTT);
				if(vVoice){	//Talk [TOGGLE]
					ActKey(KEYON+PULSE+EXEC("initLED(ToggleVoicePTTLED, 1);"));	//Put The LED ON
				}else{	//Silence [TOGGLE}	
					ActKey(KEYON+PULSE+EXEC("initLED(ToggleVoicePTTLED, 0);"));	//Put The LED OFF
				}
				if(DebugMode) printf("Mic Toggle [%d] [Actived[1] DesActived[0] / PTT [%d] [External:[0]Internal:[1]] / Mode [%d] [HOLD:[0] TOGGLE:[1]]\x0a", vVoicePTT, sPTTState, sPTTMode);
			}else{	//Talk [HOLD]
				ActKey(KEYON+DOWN+vPTT);
				ActKey(KEYON+PULSE+EXEC("initLED(ToggleVoicePTTLED, 1);"));	//Put The LED ON
			}
		}
		if(!Throttle[MSP] & !sPTTMode){	//Silence [HOLD]
			vVoicePTT=!vVoicePTT;	//reverse the flag status
			ActKey(KEYON+UP+vPTT);
			ActKey(KEYON+PULSE+EXEC("initLED(ToggleVoicePTTLED, 0);"));	//Put The LED OFF
		}
		if(DebugMode & !sPTTMode) printf("Mic Toggle [%d] [Actived[1] DesActived[0] / PTT [%d] [External:[0]Internal:[1]] / Mode [%d] PUSH:[0] TOGGLE:[1]]\x0a", vVoicePTT, sPTTState, sPTTMode);
	}
	
	//FUNCTION: Init Secure Retract
	int initSecureRectract(){
		vSecureEscapeFight=!vSecureEscapeFight;	//reverse the flag status
		if(sHardPoints) ActKey(KEYON+PULSE+EXEC("initToggleHardpoints();"));
		if(sGears) ActKey(KEYON+PULSE+EXEC("initToggleLandingGear();"));
		if(sCargo) ActKey(KEYON+PULSE+EXEC("initToggleCargoScoop();"));
		vSecureEscapeFight=!vSecureEscapeFight;
	}
	
	//FUNCTION: Switch State Function to Defercall EXEC in Other Fonctions
	int initSwitchState(int s=0){
		if(s == EF) vSLonEscapeFight=!vSLonEscapeFight;
		//if(DebugMode & s == EF)printf("vSLonEscapeFight [%d]\x0a", vSLonEscapeFight);
	}

	//FUNCTION: Toggle LED	requested, Params = Toggle Name LED, ON[1] or OFF[0] (ex:	initLED(ToggleLandingGearLED, 1)	Will up the LG LED if ToggleLandingGearLED is Define in setting (!=0))
	int initLED(int l = 0, int LEDONOFF =0){
		if(LEDONOFF == 1 & l!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+l));	//LED ON
		if(LEDONOFF == 0 & l!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-l));	//LED OFF
	}

//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
//	PIP MANAGEMENT FUNCTIONS																																	//
//		initPIPPower(x,y,z)	Params = SYS, ENG, WEP, MID																											//
//			x gets 4 PIPs, y gets 2 PIPs, if z = MID get 50/50 of x and y (3x 3y)																				//
//			If only x, balanced 1 PIP on each 2ndary power																										//
//			If no params, balances power.																														//
//		initRestorePIPPower(j)	Params = HarPoints (HP) Or FIRE (Fire) OR EF (Escape Fight) OR GM (Game Menu) OR CC (Classified Camera)							//
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
	
	//PIP Management
	int initPIPPower(int x=0, int y=0, int z=0){

		// Map out PIPs
		if(x == 0) PIPfull = 0;
		else if(x == SYS) PIPfull = PULSE+ PowerSys;
		else if(x == ENG) PIPfull = PULSE+ PowerEng;
		else if(x == WEP) PIPfull = PULSE+ PowerWep;
	
		if(y == 0) PIPhalf = 0;
		else if(y == SYS) PIPhalf = PULSE+ PowerSys;
		else if(y == ENG) PIPhalf = PULSE+ PowerEng;
		else if(y == WEP) PIPhalf = PULSE+ PowerWep;

		if(z == 0 & z != MID) PIPMid = 0;
		else if(z == MID) PIPMid = PIPhalf;
		
		// Send PIPS
		ActKey(KEYON+ CHAIN(PULSE+ BalancePower, D(PIPPulseDelay),PIPfull, D(PIPPulseDelay),PIPhalf, D(PIPPulseDelay),PIPfull, D(PIPPulseDelay),PIPfull, D(PIPPulseDelay),PIPMid));
		
		// Save the PIPS for Automatique PIP MODE RESET (OptimalPIPMode in Settings File)
		if(OptimalPIPMode){
			if(x == 0 & y == 0 & z == 0){if(vOptimalPIP != 0) vOptimalPIP = 0;}		//2 SYS 2 ENG 2 WEP (0)
			else if(z != MID | z == 0){
				if(y != 0){
					if(y == SYS){
						if(x == ENG){if(vOptimalPIP != 1) vOptimalPIP = 1;}			//4 ENG	2 SYS (1)
						else if(x == WEP){if(vOptimalPIP != 6) vOptimalPIP = 6;}	//4 WEP 2 SYS (6)
					}
					else if(y == ENG){
						if(x == SYS){if(vOptimalPIP != 3) vOptimalPIP = 3;}			//4 SYS 2 ENG (3)
						else if(x == WEP){if(vOptimalPIP != 5) vOptimalPIP = 5;}	//4 WEP 2 ENG (5)
					}
					else if(y == WEP){
						if(x == SYS){if(vOptimalPIP != 4) vOptimalPIP = 4;}			//4 SYS 2 WEP (4)
						else if(x == ENG){if(vOptimalPIP != 2) vOptimalPIP = 2;}	//4 ENG 2 WEP (2)
					}
				}
				else if(y ==0){
					if(x == SYS){if(vOptimalPIP != 10) vOptimalPIP = 10;}			//4 SYS 1 ENG 1 WEP (10)
					else if(x == ENG){if(vOptimalPIP != 11) vOptimalPIP = 11;}		//4 ENG 1 SYS 1 WEP (11)
					else if(x == WEP){if(vOptimalPIP != 12) vOptimalPIP = 12;}		//4 WEP 1 SYS 1 ENG (12)
				}
			}
			else if(z == MID){	
				if(y != 0){
					if(y == SYS & x == ENG | y == ENG & x == SYS){if(vOptimalPIP != 7) vOptimalPIP = 7;}		//3 SYS 3 ENG (7)
					else if(y == ENG & x == WEP | y == WEP & x == ENG){if(vOptimalPIP != 8) vOptimalPIP = 8;}	//3 ENG 3 WEP (8)
					else if(y == SYS | x == WEP | y == WEP | x == SYS){if(vOptimalPIP != 9) vOptimalPIP = 9;}	//3 SYS 3 WEP (9)
				}
			}
			if(DebugMode) printf("Initialising PIP Commands	[%d]\x0a", vOptimalPIP);
		}
	}
	
	//PIP Restore Management
	int initRestorePIPPower(int j=0){
		
		//Check What PIP to Restore, HarPoints (HP) Or FIRE (Fire) OR EF (Escape Fight) OR GM (Game Menu) OR CC (Classified Camera)
		if(j == FIRE) PIPRestore = vOptimalPIPFireBackup;	//Weapon Fire
		else if(j == HP) PIPRestore = vOptimalPIPHPBackup;	//HardPoints
		else if(j == EF) PIPRestore = vOptimalPIPEFBackup;	//Escape Fight
		else if(j == GM) PIPRestore = vOptimalPIPGMBackup;	//Game Menu
		else if(j == CC) PIPRestore = vOptimalPIPCCBackup;	//Classified Camera

		if(PIPRestore != vOptimalPIP){	// Send Good Backup PIPS only if previous PIPSwith is != of backup Value
			if(DebugMode)printf("Reset PIP : PIPRestore [%d] vOptimalPIP [%d]\x0a", PIPRestore, vOptimalPIP);
			if(PIPRestore == 0)ActKey(KEYON+PULSE+EXEC("initPIPPower();"));				//If no Previous PIP Mode selected Balance Power
			else if(PIPRestore == 1)ActKey(KEYON+PULSE+EXEC("initPIPPower(ENG,SYS);"));		//4 ENG	2 SYS (1)
			else if(PIPRestore == 2)ActKey(KEYON+PULSE+EXEC("initPIPPower(ENG,WEP);"));		//4 ENG 2 WEP (2)
			else if(PIPRestore == 3)ActKey(KEYON+PULSE+EXEC("initPIPPower(SYS,ENG);"));		//4 SYS 2 ENG (3)
			else if(PIPRestore == 4)ActKey(KEYON+PULSE+EXEC("initPIPPower(SYS,WEP);"));		//4 SYS 2 WEP (4)
			else if(PIPRestore == 5)ActKey(KEYON+PULSE+EXEC("initPIPPower(WEP,ENG);"));		//4 WEP 2 ENG (5)
			else if(PIPRestore == 6)ActKey(KEYON+PULSE+EXEC("initPIPPower(WEP,SYS);"));		//4 WEP 2 SYS (6)
			else if(PIPRestore == 7)ActKey(KEYON+PULSE+EXEC("initPIPPower(SYS,ENG,MID);"));	//3 SYS 3 ENG (7)
			else if(PIPRestore == 8)ActKey(KEYON+PULSE+EXEC("initPIPPower(ENG,WEP,MID);"));	//3 ENG 3 WEP (8)
			else if(PIPRestore == 9)ActKey(KEYON+PULSE+EXEC("initPIPPower(SYS,WEP,MID);"));	//3 SYS 3 WEP (9)	
			else if(PIPRestore == 10)ActKey(KEYON+PULSE+EXEC("initPIPPower(SYS);"));			//4 SYS 1 ENG 1 WEP (10)
			else if(PIPRestore == 11)ActKey(KEYON+PULSE+EXEC("initPIPPower(ENG);"));			//4 ENG 1 SYS 1 WEP (11)
			else if(PIPRestore == 12)ActKey(KEYON+PULSE+EXEC("initPIPPower(WEP);"));			//4 WEP 1 SYS 1 ENG (12)
		}
	}

//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
//	MAIN GAMES FUNCTIONS																																		//
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//

	//FUNCTION: Init Fire
	int initFire(){
		if(Joystick[TG1] | Joystick[S2]){	//PRESS THE TG1 or S2 BUTTON	
			if(SilentRuningOFFonFire & sSilentRuning){
				if(!vSLonFire){	//ShutDown Silent Runing
					vSLonFire=!vSLonFire;	//reverse the flag status
					vSilentRuningBackup = sSilentRuning;	//Backup Actual Silent Runing State
					ActKey(KEYON+PULSE+EXEC("initToggleSilentRuning();"));
				}
			}
			if(HardPointsonFireGameMode & !sHardPoints){ActKey(KEYON+PULSE+EXEC("initToggleHardpoints();"));}
			if(OptimalPIPMode){	//If Optimal Mode is Enable
				vOptimalPIPFireBackup = vOptimalPIP;	//Backup Actual PIP Mode
				if(vOptimalPIP != 6){	// Already 4xWEP 2xSYS?
					ActKey(KEYON+PULSE+EXEC("initPIPPower(WEP,SYS);"));	//4 WEP 2 SYS (6)
				}
			}			
			if(Joystick[TG1]){ActKey(KEYON+DOWN+PrimaryFire);}
			if(Joystick[S2]){ActKey(KEYON+DOWN+SecondaryFire);}
			//if(DebugMode)printf("vSLonFire [%d]\x0a", vSLonFire);
		}else{				//RELEASE THE TG1 or S2 BUTTON
			if(!Joystick[TG1]){ActKey(KEYON+UP+PrimaryFire);}
			if(!Joystick[S2]){ActKey(KEYON+UP+SecondaryFire);}
			if(OptimalPIPMode & !Joystick[TG1] & !Joystick[S2]){	//If Optimal Mode is Enable
				if(vOptimalPIPFireBackup != vOptimalPIP){
					ActKey(KEYON+PULSE+EXEC("initRestorePIPPower(FIRE);"));	//Restore Previous PIP Mode				
				}
			}			
			if(HardPointsonFireGameMode & StopFireRetractHardpoints & sHardPoints & !Joystick[S2] & !Joystick[TG1]){ActKey(KEYON+PULSE+EXEC("initToggleHardpoints();"));}
			if(vSilentRuningBackup!=0 & !Joystick[S2] & !Joystick[TG1]){
				vSilentRuningBackup = 0;
				ActKey(KEYON+PULSE+EXEC("initToggleSilentRuning();"));	//Restore Silent Runing State
			}
			if(SilentRuningOFFonFire & sSilentRuning & vSLonFire & !Joystick[S2] & !Joystick[TG1]){
				vSLonFire=!vSLonFire;	//reverse the flag status
			}
			//if(DebugMode)printf("vSLonFire [%d]\x0a", vSLonFire);
		}
	}
	
	//FUNCTION: Jettison All Cargo	
	int initJettisonCargo(){																
		if(Throttle[APUON]){
			if(sCargo){																		
				ActKey(KEYON+PULSE+JettisonAllCargo);
				if(DebugMode) printf("Jettison All Cargo\x0a");
			}else{
				if(DebugMode) printf("Jettison Need Cargo Scoop Open\x0a");
			}
		}
	}

	//FUNCTION: Init Supercruise
	int initSuperCruise(){
		if(SecureRetract & (sHardPoints | sCargo | sGears)) ActKey(KEYON+PULSE+EXEC("initSecureRectract();"));	//initSecureRectract() only if HardPoints or Cargo Scoop Or L Gears Deployed
		ActKey(KEYON+PULSE+Supercruise);
		if(DebugMode) printf("Engage SuperCruise\x0a");
	}
	
	//FUNCTION: Init FrameShiftDrive
	int initFrameShiftDrive(){
		if(SecureRetract & (sHardPoints | sCargo | sGears)) ActKey(KEYON+PULSE+EXEC("initSecureRectract();"));	//initSecureRectract() only if HardPoints or Cargo Scoop Or L Gears Deployed
		ActKey(KEYON+PULSE+FrameShiftDrive);
		if(DebugMode) printf("Engage FSD\x0a");
	}
	
	//FUNCTION: SystemJump
	int initSystemJump(){
		if(!SecureRetract & (sHardPoints | sCargo | sGears)){		//IF SecureRectract = 0 Engage FSD To match the game mechanic and don't launch the speed to 0 from mSystemJump Macro if HardPoints or Cargo Scoop Or L Gears Deployed
			ActKey(KEYON+PULSE+EXEC("initFrameShiftDrive();"));
		}else{
			if(SecureRetract & (sHardPoints | sCargo | sGears)){ActKey(KEYON+PULSE+EXEC("initSecureRectract();"));}	//initSecureRectract() only if HardPoints or Cargo Scoop Or L Gears Deployed
			ActKey(KEYON+PULSE+mSystemJump);
			if(DebugMode) printf("Engage System Jump\x0a");
		}
	}

//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
//	EXTRA GAMES FUNCTIONS																																		//
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//

	//FUNCTION: Use Supercruise while boosting if Throttle is 100%
	int initThrottleBoost(){
		if(SupecruiseOnThrottle & AxisVal(Throttle[THR_RIGHT], &axdata) >= 32767){	//Throttle All the Way Up & SupecruiseOnThrottle is Actived?
				if(SecureRetract & (sHardPoints | sCargo | sGears)){ActKey(KEYON+PULSE+EXEC("initSecureRectract();"));}	//initSecureRectract() only if HardPoints or Cargo Scoop Or L Gears Deployed
				ActKey(KEYON+PULSE+Supercruise);
				if(DebugMode) printf("SuperCruise On Throttle Engaged\x0a");
		}else{
			ActKey(KEYON+PULSE+EngineBoost);
			if(DebugMode) printf("Engine Boost\x0a");
		}
	}

	//FUNCTION: Escape Fight
	int initEscapeFight(){
		if(SecureRetract & (sHardPoints | sCargo | sGears)){ActKey(KEYON+PULSE+EXEC("initSecureRectract();"));}	//initSecureRectract() only if HardPoints or Cargo Scoop Or L Gears Deployed
		if(!sSilentRuning){	//If Silent Running is Disable, Enable it
			if(!vSLonEscapeFight){ActKey(KEYON+PULSE+EXEC("initSwitchState(EF);"));}	//ShutDown Silent Runing
			ActKey(KEYON+PULSE+EXEC("initToggleSilentRuning();"));
		}
		if(OptimalPIPMode){	//If Optimal Mode is Enable
			vOptimalPIPEFBackup = vOptimalPIP;	//Backup Actual PIP Mode
			if(vOptimalPIP != 1){	// Already 4xENG 2xSYS?			
				ActKey(KEYON+PULSE+EXEC("initPIPPower(ENG, SYS);"));	//4 ENG	2 SYS (1)
			}
			DeferCall(1500, &ActKey, KEYON+PULSE+EXEC("initPIPPower(SYS, ENG);"));	//4 SYS 2 ENG (3)
			DeferCall(10000, &ActKey, KEYON+PULSE+EXEC("initRestorePIPPower(EF);"));	//Restore Previous PIP Mode If vOptimalPIPEFBackup != 4 SYS 2 ENG (3)
		}
		ActKey(KEYON+PULSE+mEscapeFight);
		if(sSilentRuning){		//Disable Silent Runing previouly Enable
			DeferCall(4000, &ActKey, KEYON+PULSE+EXEC("initToggleSilentRuning();"));
			if(vSLonEscapeFight){DeferCall(5000, &ActKey, KEYON+PULSE+EXEC("initSwitchState(EF);"));}	//Restore Previous PIP Mode If vOptimalPIPGMBackup != 4 SYS 2 ENG (3)
		}
		if(DebugMode) printf("Escape Mode Engaged : CHECK IF GEARS AND CARGO STATE IS OK (SWITCH CS and LG) \x0a");
	}

	//FUNCTION: Request Docking
	int initRCDocking(){
		if(DebugMode) printf("Docking Initialisation\x0a");
		if(SecureRetract & (sHardPoints | sCargo | sGears)){ActKey(KEYON+PULSE+EXEC("initSecureRectract();"));}	//initSecureRectract() only if HardPoints or Cargo Scoop Or L Gears Deployed
		ActKey(KEYON+PULSE+mRequestCancelDock);
		if(OptimalPIPMode){	//If Optimal Mode is Enable
			DeferCall(3000, &ActKey, KEYON+PULSE+EXEC("initPIPPower(SYS, ENG);"));	//4 SYS 2 ENG (3)
		}
	}

	//FUNCTION: Autopilot Engage / Disengage Key
	int initEngageAPkey(){
		if (Throttle[APPAT]) ActKey(KEYON+PULSE+EXEC("initRCDocking();"));
		else if (Throttle[APAH]) ActKey(KEYON+PULSE+EXEC("initEscapeFight();"));
		else if (Throttle[APALT] & !Joystick[S3]) ActKey(KEYON+PULSE+EXEC("initSystemJump();"));
		else if (Throttle[APALT] & Joystick[S3]) ActKey(KEYON+PULSE+CancelFSD);
	}