//	Copyright (C) 2017 Thomas Duployez (CMDR Touille)
//	V2.2.03.3b	2017/02
//	Distributed freely under the MIT License.
//	
//	Permission is hereby granted, free of charge, to any person obtaining a copy
//	of this software and associated documentation files (the "Software"), to deal
//	in the Software without restriction, including without limitation the rights
//	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//	copies of the Software, and to permit persons to whom the Software is
//	furnished to do so, subject to the following conditions:
//	
//	The above copyright notice and this permission notice shall be included in all
//	copies or substantial portions of the Software.
//	
//	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//	SOFTWARE.
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
//	HARDWARE MAPPINGS																																			//
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
	
//	-------------------------LED FUNCTIONS
	
	//FUNCTION: Toggle or Flashing LED : Params => Toggle Name LED, Value(state) to Track and delay if you want the led flashing
	//Name LED can be chosen IN SETTINGS FILE according wich one you want to track   For Throttle : LED1, LED2, LED3, LED4, LED5   For Right MFD : RMFDLED1, RMFDLED2   For Left MFD : LMFDLED1, LMFDLED2	
	//ex : initLED(ToogleNVidiaCaptureVideoLED, sNVidiaCaptureVideo, 250); --> Toggle Flashing LED (chose wich one in settings) with 250ms delay (2 flash / sec) according the sNVidiaCaptureVideo state
	int initLED(int t = 0, int v = 0, int ms = 0){
		//Toggle LED
		if(t!=0 & ms == 0){	//No Delay, Toggle LED ON/OFF
		//Check Which Device
			if     (t == LED1 | t == LED2 | t == LED3 | t == LED4 | t == LED5) LED_DEVICE = &Throttle;
			else if(t == RMFDLED1 | t == RMFDLED1)                             LED_DEVICE = &RMFD;
			else if(t == LMFDLED1 | t == LMFDLED2)                             LED_DEVICE = &LMFD;
			else if(DebugMode) printf("LED should be LED1, LED2, LED3, LED4, LED5 OR RMFDLED1, RMFDLED2, LMFDLED1, LMFDLED2\x0a");
		//Check Which LED Outpout
			if     (t == LED1 | t == RMFDLED1 | t == LMFDLED1)LED_OUTPOUT = OUT_ID_LED_1;
			else if(t == LED2 | t == RMFDLED2 | t == LMFDLED2)LED_OUTPOUT = OUT_ID_LED_2;
			else if(t == LED3)                                LED_OUTPOUT = OUT_ID_LED_3;
			else if(t == LED4)                                LED_OUTPOUT = OUT_ID_LED_4;
			else if(t == LED5)                                LED_OUTPOUT = OUT_ID_LED_5;
			else if(DebugMode) printf("LED should be LED1, LED2, LED3, LED4, LED5 OR RMFDLED1, RMFDLED2, LMFDLED1, LMFDLED2\x0a");
		//Push LED Toggle
			GameOutput(LED_DEVICE, LED_OUTPOUT, v);
		}
		//Or Push LED Flashing
		else if(t!= 0 & ms !=0){	//Delay, Flashing LED
			if     (ms < 250) {ms = 250;}else if(ms > 2000){ms = 2000;}	//Flashing btw 250ms & 2000ms (2sec)
			if     (t == LED1)    {flagHoverLED1=!flagHoverLED1; flashing_T_LED1(ms);}
			else if(t == LED2)    {flagHoverLED2=!flagHoverLED2; flashing_T_LED2(ms);}
			else if(t == LED3)    {flagHoverLED3=!flagHoverLED3; flashing_T_LED3(ms);}
			else if(t == LED4)    {flagHoverLED4=!flagHoverLED4; flashing_T_LED4(ms);}
			else if(t == LED5)    {flagHoverLED5=!flagHoverLED5; flashing_T_LED5(ms);}
			else if(t == RMFDLED1){flagHoverRMFDLED1=!flagHoverRMFDLED1;flashing_RMFD_LED1(ms);}
			else if(t == RMFDLED2){flagHoverRMFDLED2=!flagHoverRMFDLED2;flashing_RMFD_LED2(ms);}
			else if(t == LMFDLED1){flagHoverLMFDLED1=!flagHoverLMFDLED1;flashing_LMFD_LED1(ms);}
			else if(t == LMFDLED2){flagHoverLMFDLED2=!flagHoverLMFDLED2;flashing_LMFD_LED2(ms);}
			else if(DebugMode) printf("LED should be LED1, LED2, LED3, LED4, LED5 OR RMFDLED1, RMFDLED2, LMFDLED1, LMFDLED2\x0a");
		}
		//else if(DebugMode) printf("LED SET	[%d]	Value	[%d]\x0a", t, v);
	}

	//FUNCTIONS: Flashing Throttle LED's
	int flashing_T_LED1(int ms = 0){if(flagHover_T_LED1 > 0){GameOutput(&Throttle, OUT_ID_LED_1, 2);DeferCall(ms, &flashing_T_LED1, ms);} else {GameOutput(&Throttle, OUT_ID_LED_1, 0);}}
	int flashing_T_LED2(int ms = 0){if(flagHover_T_LED2 > 0){GameOutput(&Throttle, OUT_ID_LED_2, 2);DeferCall(ms, &flashing_T_LED2, ms);} else {GameOutput(&Throttle, OUT_ID_LED_2, 0);}}
	int flashing_T_LED3(int ms = 0){if(flagHover_T_LED3 > 0){GameOutput(&Throttle, OUT_ID_LED_3, 2);DeferCall(ms, &flashing_T_LED3, ms);} else {GameOutput(&Throttle, OUT_ID_LED_3, 0);}}
	int flashing_T_LED4(int ms = 0){if(flagHover_T_LED4 > 0){GameOutput(&Throttle, OUT_ID_LED_4, 2);DeferCall(ms, &flashing_T_LED4, ms);} else {GameOutput(&Throttle, OUT_ID_LED_4, 0);}}
	int flashing_T_LED5(int ms = 0){if(flagHover_T_LED5 > 0){GameOutput(&Throttle, OUT_ID_LED_5, 2);DeferCall(ms, &flashing_T_LED5, ms);} else {GameOutput(&Throttle, OUT_ID_LED_5, 0);}}

	//FUNCTIONS: Flashing MFD's LED's
	int flashing_RMFD_LED1(int ms = 0){if(flagHover_RMFD_LED1 > 0){GameOutput(&RMFD, OUT_ID_LED_1, 2);DeferCall(ms, &flashing_RMFD_LED1, ms);} else {GameOutput(&RMFD, OUT_ID_LED_1, 0);}}
	int flashing_RMFD_LED2(int ms = 0){if(flagHover_RMFD_LED2 > 0){GameOutput(&RMFD, OUT_ID_LED_2, 2);DeferCall(ms, &flashing_RMFD_LED2, ms);} else {GameOutput(&RMFD, OUT_ID_LED_2, 0);}}
	int flashing_LMFD_LED1(int ms = 0){if(flagHover_LMFD_LED1 > 0){GameOutput(&LMFD, OUT_ID_LED_1, 2);DeferCall(ms, &flashing_LMFD_LED1, ms);} else {GameOutput(&LMFD, OUT_ID_LED_1, 0);}}
	int flashing_LMFD_LED2(int ms = 0){if(flagHover_LMFD_LED2 > 0){GameOutput(&LMFD, OUT_ID_LED_2, 2);DeferCall(ms, &flashing_LMFD_LED2, ms);} else {GameOutput(&LMFD, OUT_ID_LED_2, 0);}}
	
	//FUNCTIONS: PANIC LED STATES (For the FUN :) )
	int init_PANIC_LED(int ms = 0){
		if(PANIC_LED > 0){
			PANIC_LED = PANIC_LED - 1;
			DeferCall(ms*1 , &ActKey, KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT^LED1));
			DeferCall(ms*10, &ActKey, KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT^LED1));
			DeferCall(ms*2 , &ActKey, KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT^LED2));
			DeferCall(ms*9 , &ActKey, KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT^LED2));
			DeferCall(ms*3 , &ActKey, KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT^LED3));
			DeferCall(ms*8 , &ActKey, KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT^LED3));
			DeferCall(ms*4 , &ActKey, KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT^LED4));
			DeferCall(ms*7 , &ActKey, KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT^LED4));
			DeferCall(ms*5 , &ActKey, KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT^LED5));
			DeferCall(ms*6 , &ActKey, KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT^LED5));
			//if(DebugMode){printf("PANIC LED\x0a");}
			DeferCall(ms*11, &init_PANIC_LED, ms);
		}else{PANIC_LED = 6;}
	}

//	-------------------------BACKLIGHT FUNCTIONS

	//FUNCTION: Toggle or Flashing BackLight : Params => Value(see below : Check which device (v =...)) and delay if you want the Backlight flash
	//ex : initBACKLIGHT(vThrottleLightBackup, 500); --> Throttle BackLight(backup) Flashing  with 500ms delay
	int initBACKLIGHT(int v = 0, int ms = 0){
		if     (v < 0)    {v = 0;}   else if(v > 255)  {v = 255;}	//If v is out of Standard value : Replace with min or max value
	
		//Check which Device
		if     (v == vThrottleLight | v == vThrottleLightBackup | v == ThrottleLightOnIDLE)BACKLIGHT_DEVICE = &Throttle;
		else if(v == vRMFDeLight    | v == vRMFDLightBackup)                               BACKLIGHT_DEVICE = &RMFD;
		else if(v == vLMFDeLight    | v == vLMFDLightBackup)                               BACKLIGHT_DEVICE = &LMFD;
		else if(DebugMode){printf("BACKLIGHT_DEVICE Not Configured Correctly\x0a");}
		
		//Push BackLight Toggle Or Flashing?
		if(ms == 0){	//No Delay, Push BackLight Toggle
			//GameOutput(BACKLIGHT_DEVICE, OUT_ID_LED_INTENSITY, v);
			if(v > 0)GameOutput(BACKLIGHT_DEVICE, OUT_ID_LED_BACKLIGHT, 1);
			else     GameOutput(BACKLIGHT_DEVICE, OUT_ID_LED_BACKLIGHT, 0);
			//if(DebugMode)printf("Backlight Throttle LED Set to %d\x0a", v);
		}
		else if(ms != 0 & v !=0){	//Delay, Push BackLight Flashing     If BackLight Value (v) if OFF (0) we don't see Flashing ...
			if     (ms < 250) {ms = 250;}else if(ms > 2000){ms = 2000;}	//Flashing btw 250ms & 2000ms (2sec)
			//GameOutput(BACKLIGHT_DEVICE, OUT_ID_LED_INTENSITY, v);
			if (BACKLIGHT_DEVICE == &Throttle){flagHover_T_BackLight   =!flagHover_T_BackLight   ; flashing_T_BackLight(ms)   ;}
			else if(BACKLIGHT_DEVICE == &RMFD){flagHover_RMFD_BackLight=!flagHover_RMFD_BackLight; flashing_RMFD_BackLight(ms);}
			else if(BACKLIGHT_DEVICE == &LMFD){flagHover_LMFD_BackLight=!flagHover_LMFD_BackLight; flashing_LMFD_BackLight(ms);}
			else if(DebugMode){printf("Flashing BACKLIGHT_DEVICE Not Configured Correctly\x0a");}
			//if(DebugMode)printf("Backlight Flashing Throttle LED Set to %d\x0a", v);
		}
		else if(DebugMode) printf("Trying to Flash OFF BackLight ???\x0a");
	}
	
	//FUNCTIONS: Flashing Throttle BackLight
	int flashing_T_BackLight(int ms = 0){	//Throttle BackLight
		if(flagHover_T_BackLight > 0){GameOutput(&Throttle, OUT_ID_LED_BACKLIGHT, 2);DeferCall(ms, &flashing_T_BackLight, ms);	//Falshing Throttle BackLight
		}else{
			if(vThrottleLightBackup != 0)GameOutput(&Throttle, OUT_ID_LED_BACKLIGHT, 1);	//Throttle BackLight ON
			else                         GameOutput(&Throttle, OUT_ID_LED_BACKLIGHT, 0);	//Throttle BackLight OFF
		}
	}
	//FUNCTIONS: Flashing MFD BackLight
	int flashing_RMFD_BackLight(int ms = 0){	//RMFD BackLight
		if(flagHover_RMFD_BackLight > 0){GameOutput(&RMFD, OUT_ID_LED_BACKLIGHT, 2);DeferCall(ms, &flashing_RMFD_BackLight, ms);	//Falshing RMFD BackLight
		}else{
			if(vRMFDLightBackup != 0)GameOutput(&RMFD, OUT_ID_LED_BACKLIGHT, 1);	//RMFD BackLight ON
			else                     GameOutput(&RMFD, OUT_ID_LED_BACKLIGHT, 0);	//RMFD BackLight OFF
		}
	}
	int flashing_LMFD_BackLight(int ms = 0){	//LMFD BackLight
		if(flagHover_LMFD_BackLight > 0){GameOutput(&LMFD, OUT_ID_LED_BACKLIGHT, 2);DeferCall(ms, &flashing_LMFD_BackLight, ms);	//Falshing LMFD BackLight
		}else{
			if(vLMFDLightBackup != 0)GameOutput(&LMFD, OUT_ID_LED_BACKLIGHT, 1);	//LMFD BackLight ON
			else                     GameOutput(&LMFD, OUT_ID_LED_BACKLIGHT, 0);	//LMFD BackLight OFF
		}
	}	
	
//	-------------------------Set LED & THROTTLE BACLIGHT
	int initLEDStates(){
	
		//Initiate LED Backlight power on Throttle (Value 0-255)
		if(HMD){	//Set LED Backlight on Start If HMD
				vThrottleLight = ThrottleLightHMD;
				vThrottleLightBackup = ThrottleLightHMD;	//Backup the LED BackLight default value
				if(DebugMode | DebugMMode)printf("HMD -> Backlight IDLE Throttle LED Set to %d\x0a", ThrottleLightHMD);
				initBACKLIGHT(ThrottleLightHMD);
		}else{	//Set LED Backlight on Start
				vThrottleLight = ThrottleLight;
				vThrottleLightBackup = ThrottleLight;	//Backup the LED BackLight default value
				if(DebugMode | DebugMMode)printf("No HMD Or TrackIR -> Backlight IDLE Throttle LED Set to %d\x0a", vThrottleLight);
				initBACKLIGHT(ThrottleLight);
		}
		
		GameOutput(BACKLIGHT_DEVICE, OUT_ID_LED_INTENSITY, vThrottleLightBackup);
		
		//Initiate LED Backlight power On MFD
		if(USEMFD > 0){GameOutput(&RMFD, LED_INTENSITY, RMFDLight);GameOutput(&RMFD, OUT_ID_LED_BACKLIGHT, 1);}
		if(USEMFD > 1){GameOutput(&LMFD, LED_INTENSITY, LMFDLight);GameOutput(&LMFD, OUT_ID_LED_BACKLIGHT, 1);}

		//Initiate LED status all OFF
		GameOutput(&Throttle, OUT_ID_LED_1, 0);	//set Throttle LED 1 OFF
		GameOutput(&Throttle, OUT_ID_LED_2, 0);	//set Throttle LED 2 OFF
		GameOutput(&Throttle, OUT_ID_LED_3, 0);	//set Throttle LED 3 OFF
		GameOutput(&Throttle, OUT_ID_LED_4, 0);	//set Throttle LED 4 OFF
		GameOutput(&Throttle, OUT_ID_LED_5, 0);	//set Throttle LED 5 OFF
		if(USEMFD > 0){
			GameOutput(&RMFD, OUT_ID_LED_1, 0);	//set right MFD LED 1 OFF
			GameOutput(&RMFD, OUT_ID_LED_2, 0);	//set right MFD LED 2 OFF
		}
		if(USEMFD > 1){
			GameOutput(&LMFD, OUT_ID_LED_1, 0);	//set left MFD LED 1 OFF
			GameOutput(&LMFD, OUT_ID_LED_2, 0);	//set left MFD LED 2 OFF
		}	

		//Initiate LED State
		initLED(ToggleSupecruiseOnThrottleLED, SupecruiseOnThrottle);
		initLED(ToggleRCorrectionLED, sRCorrection);
		initLED(ToggleLandingGearLED, sGears);
		initLED(ToggleCargoScoopLED, sCargo);
		initLED(ToggleLightsLED, sLights);
		initLED(ToggleHardpointsLED, sHardPoints);
		initLED(ToggleCombinedFireLED, sCombinedFire);
		initLED(TogglePTTLED, sPTTState);
		initLED(ToggleVoicePTTLED, vVoicePTT);
		initLED(TogglePTTModeLED, sPTTMode);
		initLED(ToggleSilentRuningOFFonFireLED, SilentRuningOFFonFire);
		initLED(ToggleHeatSinkonSilentRuningLED, HeatSinkonSilentRuning);
		initLED(ToggleIDLEonThrottleLED, sIDLE);
		initLED(ToggleOptimalPIPModeLED, OptimalPIPMode);
		initLED(ToggleSecureRetractLED, SecureRetract);
		initLED(ToggleStopFireRetractHardpointsLED, StopFireRetractHardpoints);
		initLED(ToogleExplorerModeLED, sExplorerMode);
		
		//initLED(ToggleHardPointsonFireGameModeLED, HardPointsonFireGameMode);
		//initLED(ToggleFALED, sFlightAssist);
		//initLED(ToggleVALED, sVoiceAttack);
		//initLED(ToggleSilentRuningLED, sSilentRuning);
		//initLED(ToggleReverseThrottleLED, sRT);		
		//initLED(ToggleCameraLED, sCameraMode);
		//initLED(ToggleGameMenuLED, sGameMenu);
		//initLED(ToogleHeadLookLED, sHeadLook);
		
		init_PANIC_LED(100);
		
	}
	
	//	-------------------------Set Joystick
	//Set Default Joystick Axis
	int initJoystickAxis(){	
		MapAxis(&Joystick, JOYX, DX_X_AXIS,    AXIS_NORMAL, MAP_ABSOLUTE);	// Set Joystick Control X Axis
		MapAxis(&Joystick, JOYY, DX_Y_AXIS,    AXIS_NORMAL, MAP_ABSOLUTE);	// Set Joystick Control Y Axis
		MapAxis(&Throttle, SCX,  DX_XROT_AXIS, AXIS_NORMAL, MAP_ABSOLUTE);	// Set Slew Control X Axis
		MapAxis(&Throttle, SCY,  DX_YROT_AXIS, AXIS_NORMAL, MAP_ABSOLUTE);	// Set Slew Control Y Axis
		if(CenterJoystickMount){	//	Rotate Joystick Axis to account for center mounting position
			RotateDXAxis(DX_X_AXIS, DX_Y_AXIS, JoystickAngle);
			if(DebugMode | DebugMMode) printf("Rotate Joystick Axis [%d]° CCW(-) or CW to account center mounting position\x0a",JoystickAngle);
		}
	}

	//Joystick Curve Profile Three different presets are selectable On The Fly (FLAP position)
	int initSetJoystickCurves(){
		if     (Throttle[FLAPU]) vJoystickCurveProfile = 0;	// Flaps UP
		else if(Throttle[FLAPD]) vJoystickCurveProfile = 2;	// Flaps DOWN
		else                     vJoystickCurveProfile = 1;	// Flaps MIDDLE
		initJoystickCurves();
	}
	
	//Joystick Curve Initialising
	int initJoystickCurves(){
	
		float Zsc;	//Zoom Scale Curve Correction
		if(CenterJoystickMount){Zsc = ZoomScale(JoystickAngle);}	//Center Joystick mount : check the Joystick angle
		else{Zsc = 0;}	//else angle should be 0
		
		SetSCurve(&Joystick, JOYX, 0, JS_DEADZONE, 0, JS_CURVE[vJoystickCurveProfile], JS_ZOOM[vJoystickCurveProfile]+Zsc);
		SetSCurve(&Joystick, JOYY, 0, JS_DEADZONE, 0, JS_CURVE[vJoystickCurveProfile], JS_ZOOM[vJoystickCurveProfile]+Zsc);
		SetSCurve(&Throttle, SCX,  0, SL_DEADZONE, 0, SL_CURVE[vJoystickCurveProfile], SL_ZOOM[vJoystickCurveProfile]);
		SetSCurve(&Throttle, SCY,  0, SL_DEADZONE, 0, SL_CURVE[vJoystickCurveProfile], SL_ZOOM[vJoystickCurveProfile]);
		if (DebugMode){
			if(CenterJoystickMount & JoystickAngle != 0){
				printf("Set	Joystick Curve Profile [%d]: Curve = [%d], Zoom = [%d]+Zsc[%f]\x0a", vJoystickCurveProfile, JS_CURVE[vJoystickCurveProfile], JS_ZOOM[vJoystickCurveProfile], Zsc);
			}else{
				printf("Set	Joystick Curve Profile [%d]: Curve = [%d], Zoom = [%d]\x0a", vJoystickCurveProfile, JS_CURVE[vJoystickCurveProfile], JS_ZOOM[vJoystickCurveProfile]);
			}
			printf("Set	Slew     Curve Profile [%d]: Curve = [%d], Zoom = [%d]\x0a", vJoystickCurveProfile, SL_CURVE[vJoystickCurveProfile], SL_ZOOM[vJoystickCurveProfile]);
		}
	}
	
	//Joystick Optimal ZoomScale (to reach the corner of the axes when Joystick is Rotated : Center Mount posisiton)
	float ZoomScale(float ang){
		ang = ang * 3.1415926 / 180;	// convert angle from degrees into radians
		return 2 / ln(2) * ln(abs(cos(ang) + abs(sin(ang))));	// returns the optimal zoom scale
	}
	
	//	-------------------------Set Throttle
	//Set Default Throttle Axis
	int initThrottleAxis(){	
		MapAxis(&Throttle, THR_RIGHT, DX_Z_AXIS,      AXIS_NORMAL, MAP_ABSOLUTE);		// Set Right Throttle
		MapAxis(&Throttle, THR_LEFT , 0,              AXIS_NORMAL, MAP_ABSOLUTE);		// Set Left Throttle / DX_ZROT_AXIS / We don't Use It Yet In ED
		MapAxis(&Throttle, THR_FC   , DX_SLIDER_AXIS, AXIS_NORMAL, MAP_ABSOLUTE);		// Set Friction Control Axis Curve (Sensor Range Zoom Scaling) 
		SetCustomCurve(&Throttle, THR_FC, LIST(0,0, 33,25, 66,50, 80,75, 100,100));		// (OPTIONAL OVERRIDE) (Linear Recommended in ED) *LIST(Axis physical position, Axis output Value)
	}
	
	//Set Throttle Curve two different presets are selectable On The Fly (S3 + RED Button on Throttle Arm)
	int initSetThrottleCurves(){
		vThrottleCurveProfile=!vThrottleCurveProfile;
		if(vThrottleCurveProfile){
			if(!AfterburnerDetent)SetJCurve(&Throttle, THR_RIGHT, 50, 50);	//Without Warthog Physical Afterburner Detent
			else                  SetJCurve(&Throttle, THR_RIGHT, 65, 95);	//Or With Detent. At 65% of the physical controller’s axis travel, the DirectX axis must have reached 95% of the axis value.
		}else{
			if(ThrottleAxisRange)SetSCurve(&Throttle, THR_RIGHT, 0, 0, 0, 2, -3);	//Full Range Precision
			else                 SetSCurve(&Throttle, THR_RIGHT, 0, 0, 0, 3, -3);	//Forward only Precision
		}
		DXAxis(DX_Z_AXIS, -AxisVal(Throttle[THR_RIGHT], &axdata));
		if(DebugMode)printf("Set	Throttle Curve Profile [%d]\x0a", vThrottleCurveProfile);
	}

	//	-------------------------Set Rudders	
	//Set Rudders Axis
	int initRudders(){
		MapAxis(&TFRPRudder, TRUDDER,  DX_Z_AXIS, AXIS_NORMAL,   MAP_ABSOLUTE);
		MapAxis(&TFRPRudder, TRPLEFT,  DX_X_AXIS, AXIS_REVERSED, MAP_ABSOLUTE);
		MapAxis(&TFRPRudder, TRPRIGHT, DX_Y_AXIS, AXIS_REVERSED, MAP_ABSOLUTE);
	}