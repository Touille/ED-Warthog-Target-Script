//	Copyright (C) 2017 Thomas Duployez (CMDR Touille)
//	V2.2.03.3b	2017/02
//	Distributed freely under the MIT License.
//	
//	Permission is hereby granted, free of charge, to any person obtaining a copy
//	of this software and associated documentation files (the "Software"), to deal
//	in the Software without restriction, including without limitation the rights
//	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//	copies of the Software, and to permit persons to whom the Software is
//	furnished to do so, subject to the following conditions:
//	
//	The above copyright notice and this permission notice shall be included in all
//	copies or substantial portions of the Software.
//	
//	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//	SOFTWARE.
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
//	HARDWARE MAPPINGS																																			//
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
	
	//We, now, Use GameOutput to reduce overhead on software
	
	//FUNCTION: Toggle LED	Params = Toggle Name LED, Value(state) to Track and delay if you want the led flashing
	//Name LED can be chosen IN SETTINGS FILE according wich one you want to track   For Throttle : LED1, LED2, LED3, LED4, LED5   For Right MFD : RMFDLED1, RMFDLED2   For Left MFD : LMFDLED1, LMFDLED2	
	//ex : initLED(ToogleNVidiaCaptureVideoLED, sNVidiaCaptureVideo, 250); --> Toggle Flashing LED (chose wich one in settings) with 250ms delay (2 flash / sec) according the sNVidiaCaptureVideo state
	int initLED(int t = 0, int v = 0, int ms = 0){
		if(t!=0 & ms == 0){	//No Delay, Toggle LED ON/OFF

			//Check Which Device
			if     (t == LED1 | t == LED2 | t == LED3 | t == LED4 | t == LED5)    {LED_DEVICE = &Throttle;}
			else if(t == RMFDLED1 | t == RMFDLED1 | t == LMFDLED1 | t == LMFDLED2){LED_DEVICE = &RMFD;}
			else{
				if(DebugMode) printf("LED should be LED1, LED2, LED3, LED4, LED5 OR RMFDLED1, RMFDLED2, LMFDLED1, LMFDLED2\x0a");
			}
			
			//Check Which LED Outpout
			if     (t == LED1 | t == RMFDLED1 | t == LMFDLED1){LED_OUTPOUT = OUT_ID_LED_1;}
			else if(t == LED2 | t == RMFDLED2 | t == LMFDLED2){LED_OUTPOUT = OUT_ID_LED_2;}
			else if(t == LED3)                                {LED_OUTPOUT = OUT_ID_LED_3;}
			else if(t == LED4)                                {LED_OUTPOUT = OUT_ID_LED_4;}
			else if(t == LED5)                                {LED_OUTPOUT = OUT_ID_LED_5;}
			else{
				if(DebugMode) printf("LED should be LED1, LED2, LED3, LED4, LED5 OR RMFDLED1, RMFDLED2, LMFDLED1, LMFDLED2\x0a");
			}
			
			//Push LED Toggle
			GameOutput(LED_DEVICE, LED_OUTPOUT, v);
			
		}
		else if(t!= 0 & ms !=0){	//Delay Flashing LED
			if     (ms < 250) {ms = 250 ;}else if(ms > 2000){ms = 2000;}	//Flashing btw 250ms & 2000ms (2sec) : you can change this value
			if     (t == LED1)    {flagHoverLED1=!flagHoverLED1; flashingLED1(ms);}
			else if(t == LED2)    {flagHoverLED2=!flagHoverLED2; flashingLED2(ms);}
			else if(t == LED3)    {flagHoverLED3=!flagHoverLED3; flashingLED3(ms);}
			else if(t == LED4)    {flagHoverLED4=!flagHoverLED4; flashingLED4(ms);}
			else if(t == LED5)    {flagHoverLED5=!flagHoverLED5; flashingLED5(ms);}
			else if(t == RMFDLED1){flagHoverRMFDLED1=!flagHoverRMFDLED1;flashingRMFDLED1(ms);}
			else if(t == RMFDLED2){flagHoverRMFDLED2=!flagHoverRMFDLED2;flashingRMFDLED2(ms);}
			else if(t == LMFDLED1){flagHoverLMFDLED1=!flagHoverLMFDLED1;flashingLMFDLED1(ms);}
			else if(t == LMFDLED2){flagHoverLMFDLED2=!flagHoverLMFDLED2;flashingLMFDLED2(ms);}			
			else{
				if(DebugMode) printf("LED should be LED1, LED2, LED3, LED4, LED5 OR RMFDLED1, RMFDLED2, LMFDLED1, LMFDLED2\x0a");
			}
		}else{
			//if(DebugMode) printf("LED SET	[%d]	Value	[%d]\x0a", t, v);
		}
	}

	//FUNCTIONS: Flashing Throttle LED
	int flashingLED1(int ms = 0){	//Throttle LED1
		if(flagHoverLED1 > 0){GameOutput(&Throttle, OUT_ID_LED_1, 2);DeferCall(ms, &flashingLED1, ms);	//Falshing LED
		}else{GameOutput(&Throttle, OUT_ID_LED_1, 0);}	//LED OFF
	}
	int flashingLED2(int ms = 0){	//Throttle LED2
		if(flagHoverLED2 > 0){GameOutput(&Throttle, OUT_ID_LED_2, 2);DeferCall(ms, &flashingLED2, ms);	//Falshing LED
		}else{GameOutput(&Throttle, OUT_ID_LED_2, 0);}	//LED OFF
	}
	int flashingLED3(int ms = 0){	//Throttle LED3
		if(flagHoverLED3 > 0){GameOutput(&Throttle, OUT_ID_LED_3, 2);DeferCall(ms, &flashingLED3, ms);	//Falshing LED
		}else{GameOutput(&Throttle, OUT_ID_LED_3, 0);}	//LED OFF
	}
	int flashingLED4(int ms = 0){	//Throttle LED4
		if(flagHoverLED4 > 0){GameOutput(&Throttle, OUT_ID_LED_4, 2);DeferCall(ms, &flashingLED4, ms);	//Falshing LED
		}else{GameOutput(&Throttle, OUT_ID_LED_4, 0);}	//LED OFF
	}
	int flashingLED5(int ms = 0){	//Throttle LED5
		if(flagHoverLED5 > 0){GameOutput(&Throttle, OUT_ID_LED_5, 2);DeferCall(ms, &flashingLED5, ms);	//Falshing LED
		}else{GameOutput(&Throttle, OUT_ID_LED_5, 0);}	//LED OFF
	}

	//FUNCTIONS: Flashing MFD LED
	int flashingRMFDLED1(int ms = 0){	//Right MFD LED1
		if(flagHoverRMFDLED1 > 0){GameOutput(&RMFD, OUT_ID_LED_1, 2);DeferCall(ms, &flashingRMFDLED1, ms);	//Falshing LED
		}else{GameOutput(&RMFD, OUT_ID_LED_1, 0);}	//LED OFF
	}
	int flashingRMFDLED2(int ms = 0){	//Right MFD LED2
		if(flagHoverRMFDLED2 > 0){GameOutput(&RMFD, OUT_ID_LED_2, 2);DeferCall(ms, &flashingRMFDLED2, ms);	//Falshing LED
		}else{GameOutput(&RMFD, OUT_ID_LED_2, 0);}	//LED OFF
	}
	int flashingLMFDLED1(int ms = 0){	//Left MFD LED1
		if(flagHoverLMFDLED1 > 0){GameOutput(&LMFD, OUT_ID_LED_1, 2);DeferCall(ms, &flashingLMFDLED1, ms);	//Falshing LED
		}else{GameOutput(&LMFD, OUT_ID_LED_1, 0);}	//LED OFF
	}
	int flashingLMFDLED2(int ms = 0){	//Left MFD LED2
		if(flagHoverLMFDLED2 > 0){GameOutput(&LMFD, OUT_ID_LED_2, 2);DeferCall(ms, &flashingLMFDLED2, ms);	//Falshing LED
		}else{GameOutput(&LMFD, OUT_ID_LED_2, 0);}	//LED OFF
	}

	//	-------------------------Set LED
	int initLEDStates(){
	
		//Initiate LED Backlight power on Throttle (Value 0-255)
		if(HMD){	//Set LED Backlight on Start If HMD
				vThrottleLight = ThrottleLightHMD;
				vThrottleLightBackup = ThrottleLightHMD;	//Backup the LED Backlight default value
				if(DebugMode | DebugMMode)printf("HMD -> Backlight IDLE Throttle LED Set to %d\x0a", ThrottleLightHMD);
				GameOutput(&Throttle, LED_INTENSITY, ThrottleLightHMD);
				GameOutput(&Throttle, OUT_ID_LED_BACKLIGHT, 1);
		}else{	//Set LED Backlight on Start
				vThrottleLight = ThrottleLight;
				vThrottleLightBackup = ThrottleLight;	//Backup the LED Backlight default value
				if(DebugMode | DebugMMode)printf("No HMD Or TrackIR -> Backlight IDLE Throttle LED Set to %d\x0a", vThrottleLight);
				GameOutput(&Throttle, LED_INTENSITY, ThrottleLight);
				GameOutput(&Throttle, OUT_ID_LED_BACKLIGHT, 1);
		}

		//Initiate LED Backlight power On MFD
		if(USEMFD > 0){GameOutput(&RMFD, LED_INTENSITY, RMFDLight);GameOutput(&RMFD, OUT_ID_LED_BACKLIGHT, 1);}
		if(USEMFD > 1){GameOutput(&LMFD, LED_INTENSITY, LMFDLight);GameOutput(&LMFD, OUT_ID_LED_BACKLIGHT, 1);}

		//Initiate LED status all OFF
		GameOutput(&Throttle, OUT_ID_LED_1, 0);
		GameOutput(&Throttle, OUT_ID_LED_2, 0);
		GameOutput(&Throttle, OUT_ID_LED_3, 0);
		GameOutput(&Throttle, OUT_ID_LED_4, 0);
		GameOutput(&Throttle, OUT_ID_LED_5, 0);
		if(USEMFD > 0){
			GameOutput(&RMFD, OUT_ID_LED_1, 0);	//set right MFD LED 1 OFF
			GameOutput(&RMFD, OUT_ID_LED_2, 0);	//set right MFD LED 2 OFF
		}
		if(USEMFD > 1){
			GameOutput(&LMFD, OUT_ID_LED_1, 0);	//set left MFD LED 1 OFF
			GameOutput(&LMFD, OUT_ID_LED_2, 0);	//set left MFD LED 2 OFF
		}	

		//Initiate Led State
		initLED(ToggleSupecruiseOnThrottleLED, SupecruiseOnThrottle);
		initLED(ToggleRCorrectionLED, sRCorrection);
		initLED(ToggleLandingGearLED, sGears);
		initLED(ToggleCargoScoopLED, sCargo);
		initLED(ToggleLightsLED, sLights);
		initLED(ToggleHardpointsLED, sHardPoints);
		initLED(ToggleCombinedFireLED, sCombinedFire);
		initLED(TogglePTTLED, sPTTState);
		initLED(ToggleVoicePTTLED, vVoicePTT);
		initLED(TogglePTTModeLED, sPTTMode);
		initLED(ToggleSilentRuningOFFonFireLED, SilentRuningOFFonFire);
		initLED(ToggleHeatSinkonSilentRuningLED, HeatSinkonSilentRuning);
		initLED(ToggleIDLEonThrottleLED, sIDLE);
		initLED(ToggleOptimalPIPModeLED, OptimalPIPMode);
		initLED(ToggleSecureRetractLED, SecureRetract);
		initLED(ToggleStopFireRetractHardpointsLED, StopFireRetractHardpoints);
		initLED(ToogleExplorerModeLED, sExplorerMode);
		
		//initLED(ToggleHardPointsonFireGameModeLED, HardPointsonFireGameMode);
		//initLED(ToggleFALED, sFlightAssist);
		//initLED(ToggleVALED, sVoiceAttack);
		//initLED(ToggleSilentRuningLED, sSilentRuning);
		//initLED(ToggleReverseThrottleLED, sRT);		
		//initLED(ToggleCameraLED, sCameraMode);
		//initLED(ToggleGameMenuLED, sGameMenu);
		//initLED(ToogleHeadLookLED, sHeadLook);
		
	}
	
	//	-------------------------Set Joystick
	//Set Default Joystick Axis
	int initJoystickAxis(){	
		MapAxis(&Joystick, JOYX, DX_X_AXIS,    AXIS_NORMAL, MAP_ABSOLUTE);	// Set Joystick Control X Axis
		MapAxis(&Joystick, JOYY, DX_Y_AXIS,    AXIS_NORMAL, MAP_ABSOLUTE);	// Set Joystick Control Y Axis
		MapAxis(&Throttle, SCX,  DX_XROT_AXIS, AXIS_NORMAL, MAP_ABSOLUTE);	// Set Slew Control X Axis
		MapAxis(&Throttle, SCY,  DX_YROT_AXIS, AXIS_NORMAL, MAP_ABSOLUTE);	// Set Slew Control Y Axis
		if(CenterJoystickMount){	//	Rotate Joystick Axis to account for center mounting position
			RotateDXAxis(DX_X_AXIS, DX_Y_AXIS, JoystickAngle);
			if(DebugMode | DebugMMode) printf("Rotate Joystick Axis [%d]° CCW(-) or CW to account center mounting position\x0a",JoystickAngle);
		}
	}

	//Joystick Curve Profile Three different presets are selectable On The Fly (FLAP position)
	int initSetJoystickCurves(){
		if     (Throttle[FLAPU]) vJoystickCurveProfile = 0;	// Flaps UP
		else if(Throttle[FLAPD]) vJoystickCurveProfile = 2;	// Flaps DOWN
		else                     vJoystickCurveProfile = 1;	// Flaps MIDDLE
		initJoystickCurves();
	}
	
	//Joystick Curve Initialising
	int initJoystickCurves(){
	
		float Zsc;	//Zoom Scale Curve Correction
		if(CenterJoystickMount){Zsc = ZoomScale(JoystickAngle);}	//Center Joystick mount : check the Joystick angle
		else{Zsc = 0;}	//else angle should be 0
		
		SetSCurve(&Joystick, JOYX, 0, JS_DEADZONE, 0, JS_CURVE[vJoystickCurveProfile], JS_ZOOM[vJoystickCurveProfile]+Zsc);
		SetSCurve(&Joystick, JOYY, 0, JS_DEADZONE, 0, JS_CURVE[vJoystickCurveProfile], JS_ZOOM[vJoystickCurveProfile]+Zsc);
		SetSCurve(&Throttle, SCX,  0, SL_DEADZONE, 0, SL_CURVE[vJoystickCurveProfile], SL_ZOOM[vJoystickCurveProfile]);
		SetSCurve(&Throttle, SCY,  0, SL_DEADZONE, 0, SL_CURVE[vJoystickCurveProfile], SL_ZOOM[vJoystickCurveProfile]);
		if (DebugMode){
			if(CenterJoystickMount & JoystickAngle != 0){
				printf("Set	Joystick Curve Profile [%d]: Curve = [%d], Zoom = [%d]+Zsc[%f]\x0a", vJoystickCurveProfile, JS_CURVE[vJoystickCurveProfile], JS_ZOOM[vJoystickCurveProfile], Zsc);
			}else{
				printf("Set	Joystick Curve Profile [%d]: Curve = [%d], Zoom = [%d]\x0a", vJoystickCurveProfile, JS_CURVE[vJoystickCurveProfile], JS_ZOOM[vJoystickCurveProfile]);
			}
			printf("Set	Slew     Curve Profile [%d]: Curve = [%d], Zoom = [%d]\x0a", vJoystickCurveProfile, SL_CURVE[vJoystickCurveProfile], SL_ZOOM[vJoystickCurveProfile]);
		}
	}
	
	//Joystick Optimal ZoomScale (to reach the corner of the axes when Joystick is Rotated : Center Mount posisiton)
	float ZoomScale(float ang){
		ang = ang * 3.1415926 / 180;	// convert angle from degrees into radians
		return 2 / ln(2) * ln(abs(cos(ang) + abs(sin(ang))));	// returns the optimal zoom scale
	}
	
	//	-------------------------Set Throttle
	//Set Default Throttle Axis
	int initThrottleAxis(){	
		MapAxis(&Throttle, THR_RIGHT, DX_Z_AXIS,      AXIS_NORMAL, MAP_ABSOLUTE);		// Set Right Throttle
		MapAxis(&Throttle, THR_LEFT , 0,              AXIS_NORMAL, MAP_ABSOLUTE);		// Set Left Throttle / DX_ZROT_AXIS / We don't Use It Yet In ED
		MapAxis(&Throttle, THR_FC   , DX_SLIDER_AXIS, AXIS_NORMAL, MAP_ABSOLUTE);		// Set Friction Control Axis Curve (Sensor Range Zoom Scaling) 
		SetCustomCurve(&Throttle, THR_FC, LIST(0,0, 33,25, 66,50, 80,75, 100,100));		// (OPTIONAL OVERRIDE) (Linear Recommended in ED) *LIST(Axis physical position, Axis output Value)
	}
	
	//Set Throttle Curve two different presets are selectable On The Fly (S3 + RED Button on Throttle Arm)
	int initSetThrottleCurves(){
		vThrottleCurveProfile=!vThrottleCurveProfile;
		if(vThrottleCurveProfile){
			if(!AfterburnerDetent)SetJCurve(&Throttle, THR_RIGHT, 50, 50);	//Without Warthog Physical Afterburner Detent
			else                  SetJCurve(&Throttle, THR_RIGHT, 65, 95);	//Or With Detent. At 65% of the physical controller’s axis travel, the DirectX axis must have reached 95% of the axis value.
		}else{
			if(ThrottleAxisRange)SetSCurve(&Throttle, THR_RIGHT, 0, 0, 0, 2, -3);	//Full Range Precision
			else                 SetSCurve(&Throttle, THR_RIGHT, 0, 0, 0, 3, -3);	//Forward only Precision
		}
		DXAxis(DX_Z_AXIS, -AxisVal(Throttle[THR_RIGHT], &axdata));
		if(DebugMode)printf("Set	Throttle Curve Profile [%d]\x0a", vThrottleCurveProfile);
	}

	//	-------------------------Set Rudders	
	//Set Rudders Axis
	int initRudders(){
		MapAxis(&TFRPRudder, TRUDDER,  DX_Z_AXIS, AXIS_NORMAL,   MAP_ABSOLUTE);
		MapAxis(&TFRPRudder, TRPLEFT,  DX_X_AXIS, AXIS_REVERSED, MAP_ABSOLUTE);
		MapAxis(&TFRPRudder, TRPRIGHT, DX_Y_AXIS, AXIS_REVERSED, MAP_ABSOLUTE);
	}