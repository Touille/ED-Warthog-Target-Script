//	Copyright (C) 2017 Thomas Duployez (CMDR Touille)
//	V2.2.03.2b	2017/01/14
//	Distributed freely under the MIT License.
//	
//	Permission is hereby granted, free of charge, to any person obtaining a copy
//	of this software and associated documentation files (the "Software"), to deal
//	in the Software without restriction, including without limitation the rights
//	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//	copies of the Software, and to permit persons to whom the Software is
//	furnished to do so, subject to the following conditions:
//	
//	The above copyright notice and this permission notice shall be included in all
//	copies or substantial portions of the Software.
//	
//	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//	SOFTWARE.
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
//	TOGGLE GAMES FUNCTIONS																																		//
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//

	//TOGGLE: Landing Gear	
	int initToggleLandingGear(){
		if(!Joystick[S3]){
			if(vSecureEscapeFight){	//If initSecureRectract() initialise This
				sGears=!sGears;	//reverse the flag status
				if(DebugMode)printf("Landing Gear SecureEscapeFight [%d]\x0a", vSecureEscapeFight);
			}else{	//Or Change the flag status with the switch position
				if(Throttle[EACON]) sGears = 1;	//Switch position is UP : Landing Gear Is Deployed
				else sGears = 0;	//Switch position is DOWN : Landing Gear Is Retracted
			}
			if(sGears & !vLG){	//vLG is there if initSecureRectract() initialise This
				vLG=!vLG;	//Reset On The FLY : Just switch
				ActKey(KEYON+PULSE+LandingGear);			
				ActKey(KEYON+PULSE+EXEC("initLED(ToggleLandingGearLED, 1);"));	//Put The LED ON
			}else if (!sGears & vLG){	//vLG is there if initSecureRectract() initialise This
				vLG=!vLG;	//Reset On The FLY : Just switch
				ActKey(KEYON+PULSE+LandingGear);
				ActKey(KEYON+PULSE+EXEC("initLED(ToggleLandingGearLED, 0);"));	//Put The LED OFF
			}else{
				if(DebugMode) printf("Landing Gear Reset On The Fly\x0a");
			}
		}else{	//Reset The Flag On The FLY S3 + SWITCH
			vLG=!vLG;	//Reset vLG
		}
		if(DebugMode)printf("Landing Gear	[%d]	[DEPLOYED:[1] RETRACTED:[0]]\x0a", sGears);
	}
	
	//TOGGLE: Cargo Scoop	
	int initToggleCargoScoop(){																
		if(!Joystick[S3]){
			if(vSecureEscapeFight){	//If initSecureRectract() initialise This
				sCargo=!sCargo;	//reverse the flag status
				if(DebugMode)printf("Cargo Scoop SecureEscapeFight [%d]\x0a", vSecureEscapeFight);
			}else{	//Or Change the flag status with the switch position
				if(Throttle[RDRNRM]) sCargo = 1;	//Switch position is UP : Cargo Scoop Is Deployed
				else sCargo = 0;	//Switch position is DOWN : Cargo Scoop Is Retracted
			}
			if(sCargo & !vCS){	//vCS is there if initSecureRectract() initialise This
				vCS=!vCS;	//Reset On The FLY : Just switch
				ActKey(KEYON+PULSE+CargoScoop);				
				ActKey(KEYON+PULSE+EXEC("initLED(ToggleCargoScoopLED, 1);"));	//Put The LED ON
			}else if(!sCargo & vCS){	//vCS is there if initSecureRectract() initialise This
				vCS=!vCS;	//Reset On The FLY : Just switch
				ActKey(KEYON+PULSE+CargoScoop);
				ActKey(KEYON+PULSE+EXEC("initLED(ToggleCargoScoopLED, 0);"));	//Put The LED OFF
			}else{
				if(DebugMode) printf("Cargo Scoop Reset On The Fly\x0a");
			}
		}else{	//Reset The Flag On The FLY S3 + SWITCH
			vCS=!vCS;	//Reset vCS
		}
		if(DebugMode)printf("Cargo Scoop	[%d]	[DEPLOYED:[1] RETRACTED:[0]]\x0a", sCargo);
	}

	//TOGGLE: Light	
	int initToggleLights(){
		if(!Joystick[S3]){
			if(Throttle[EFRNORM]) sLights = 1;	//Switch position is UP : Light Is ON
			else sLights = 0;	//Switch position is DOWN : Light Is OFF
			ActKey(KEYON+PULSE+ShipLights);
			if(sLights)ActKey(KEYON+PULSE+EXEC("initLED(ToggleLightsLED, 1);"));	//Put The LED ON
			else ActKey(KEYON+PULSE+EXEC("initLED(ToggleLightsLED, 0);"));	//Put The LED OFF
		}
		if(DebugMode) printf("Light		[%d]	[ON:[1] OFF:[0]]\x0a", sLights);
	}
	
	//TOGGLE: HardPoints	
	int initToggleHardpoints(){
		if(!Joystick[S3]){	//Reset On The FLY S3 + SWITCH
			if(vSecureEscapeFight){	//If initSecureRectract() initialise This Just Display Msg (Hardpoint is Mapped on Button : No Position)
				if(DebugMode)printf("HardPoints SecureEscapeFight [%d]\x0a", vSecureEscapeFight);
			}
			sHardPoints=!sHardPoints;	//reverse the flag status
			ActKey(KEYON+PULSE+DeployHardpoints);
			if(sHardPoints){
				if(OptimalPIPMode){	//If Optimal Mode is Enable
					vOptimalPIPHPBackup = vOptimalPIP;	//Backup Actual PIP Mode
					if(vOptimalPIP != 6){	// Already 4xWEP 2xSYS?
						ActKey(KEYON+PULSE+EXEC("initPIPPower(WEP,SYS);"));	//4 WEP 2 SYS (6)
					}
				}
				ActKey(KEYON+PULSE+EXEC("initLED(ToggleHardpointsLED, 1);"));	//Put The LED ON
			}else{
				if(OptimalPIPMode){	//If Optimal Mode is Enable
					if(vOptimalPIPHPBackup != vOptimalPIP){
						ActKey(KEYON+PULSE+EXEC("initRestorePIPPower(HP);"));	//Restore Previous PIP Mode
					}
				}
				ActKey(KEYON+PULSE+EXEC("initLED(ToggleHardpointsLED, 0);"));	//Put The LED OFF
			}
		}else{	//Reset The Flag On The FLY S3 + SWITCH
			sHardPoints=!sHardPoints;	//reverse the flag status
		}
		if(DebugMode) printf("HardPoints	[%d]	[DEPLOYED:[1] RETRACTED:[0]]\x0a", sHardPoints);
	}

	//TOGGLE: Silent Runing
	int initToggleSilentRuning(){
		if(Joystick[H3D] | Joystick[TG1] | Joystick[S2] | vSLonFire){
			if(SilentRuningGameMode){	//Silent Runing [TOGGLE] Mode Ingame
				vSL=!vSL;	//reverse the [TOGGLE] flag status
				if(vSL){	//Silent Runing [TOGGLE] Mode First Pulse Engage
					sSilentRuning=!sSilentRuning;	//reverse the silent runing flag status
					if(sSilentRuning){	//If Silent Runing Enable
						if(HeatSinkonSilentRuning){	//Check if Heat Sink on Silent Runing is Enable
							ActKey(KEYON+PULSE+mHeatSinkonSilentRuning);	//Call The Heat Sink on Silent Running Macro
							if(DebugMode) printf("Heat Sink On Silent Runing	[%d]	[ON:[1] OFF:[0]]\x0a", sSilentRuning);
						}else{	//If Heat Sink on Silent Runing is Disable
							ActKey(KEYON+PULSE+SilentRunning);	//Push The Silent Running Key
						}
						ActKey(KEYON+PULSE+EXEC("initLED(ToggleSilentRuningLED, 1);"));	//Put The LED ON
					}
					if(DebugMode) printf("Silent Runing	Toggle 1rst Push [%d]	[ENABLE:[1] DISABLE:[0]]\x0a", sSilentRuning);
				}else{	//Silent Runing [TOGGLE] Mode Second Pulse DisEngage
					sSilentRuning=!sSilentRuning;	//reverse the silent runing flag status
					ActKey(KEYON+PULSE+SilentRunning);	//Push The Silent Running Key
					ActKey(KEYON+PULSE+EXEC("initLED(ToggleSilentRuningLED, 0);"));	//Put The LED OFF
					if(DebugMode) printf("Silent Runing	Toggle 2nd  Push [%d]	[ENABLE:[1] DISABLE:[0]]\x0a", sSilentRuning);
				}
			}else{	//Silent Runing [HOLD] Mode Engage
				sSilentRuning=!sSilentRuning; //reverse the flag status
				ActKey(KEYON+DOWN+SilentRunning);	//Push DOWN The Silent Running Key
				ActKey(KEYON+PULSE+EXEC("initLED(ToggleSilentRuningLED, 1);"));	//Put The LED ON
				if(DebugMode) printf("Silent Runing	Hold Push [%d]	[ENABLE:[1] DISABLE:[0]]\x0a", sSilentRuning);
			}
		}else{
			if(!SilentRuningGameMode & sSilentRuning){		//Silent Runing [HOLD] Mode DisEngage
				sSilentRuning=!sSilentRuning;	//reverse the flag status
				ActKey(KEYON+UP+SilentRunning);	//Push UP The Silent Running Key
				ActKey(KEYON+PULSE+EXEC("initLED(ToggleSilentRuningLED, 0);"));	//Put The LED OFF
				if(DebugMode) printf("Silent Runing	Hold Released [%d]	[ENABLE:[1] DISABLE:[0]]\x0a", sSilentRuning);
			}
		}
	}

	//TOGGLE: Enhanced Joystick Curves tailored for Flight Assist Off ONLY IF Rotational Correction is Enable
	int initToggleEnhancedFAOFF(){																	
		if(Joystick[S4]){	//If Button Is Pushed
			if(FlightAssistGameMode){	//FA [TOGGLE] Mode Ingame
				vFA=!vFA;	//reverse the flag status
				if(!sRCorrection){		//If Rotational Correction is OFF, Just Flight
					ActKey(KEYON+PULSE+FlightAssist);
					if(vFA){if(DebugMode) printf("FAOFF [Toggle] Engaged\x0a");}
					if(!vFA){if(DebugMode) printf("FAOFF [Toggle] Disengaged\x0a");}
				}else{	//If Rotational Correction is ON, Adjust Curves
					if(vFA){	//FA [TOGGLE] Mode First Pulse Engage
						vJoystickCurveProfileBackup = vJoystickCurveProfile;	//Backup Current Curves
						vJoystickCurveProfile = FAOffCurve;	//Apply the Setting FAOffCurve (Settings)
						if(vJoystickCurveProfileBackup != FAOffCurve){	//Only if Previous Curve is != from FAOffCurrve preset						
							ActKey(KEYON+PULSE+EXEC("initJoystickCurves();"));
							if(DebugMode) printf("EnhancedFAOFF [Toggle] Engaged\x0a");
						}
						ActKey(KEYON+PULSE+FlightAssist);						
						ActKey(KEYON+PULSE+EXEC("initLED(ToggleFALED, 1);"));	//Put The LED ON
					}else{	//FA [TOGGLE] Mode Second Pulse DisEngage				
						vJoystickCurveProfile = vJoystickCurveProfileBackup;	//Restore Previous Curves
						if(vJoystickCurveProfileBackup != FAOffCurve){	//Only if Previous Curve is != from FAOffCurrve preset						
							ActKey(KEYON+PULSE+EXEC("initJoystickCurves();"));
							if(DebugMode) printf("EnhancedFAOFF [Toggle] Disengaged\x0a");printf("Curve Profile Return to Default\x0a");
						}
						ActKey(KEYON+PULSE+FlightAssist);
						ActKey(KEYON+PULSE+EXEC("initLED(ToggleFALED, 0);"));	//Put The LED OFF
					}
				}
			}else{	//FA [HOLD] Mode Ingame Engage
				if(!sRCorrection){	//If Rotational Correction is OFF, Just Flight
					ActKey(KEYON+DOWN+FlightAssist);
					if(DebugMode)printf("FAOFF [HOLD] Engaged\x0a");
				}else{	//If Rotational Correction is ON, Adjust Curves
					vJoystickCurveProfileBackup = vJoystickCurveProfile;	//Backup Current Curves
					vJoystickCurveProfile = FAOffCurve;	//Apply the Setting FAOffCurve (Settings)
					if(vJoystickCurveProfileBackup != FAOffCurve){	//Only if Previous Curve is != from FAOffCurrve preset						
						ActKey(KEYON+PULSE+EXEC("initJoystickCurves();"));
						if(DebugMode)printf("EnhancedFAOFF [HOLD] Engaged\x0a");
					}
					ActKey(KEYON+DOWN+FlightAssist);
					ActKey(KEYON+PULSE+EXEC("initLED(ToggleFALED, 1);"));	//Put The LED ON
				}
			}
		}else{	//If Button Is Released
			if(!FlightAssistGameMode){	//FA [HOLD] Mode Ingame DisEngage
				if(!sRCorrection){	//If Rotational Correction is OFF, Just Flight
					ActKey(KEYON+UP+FlightAssist);
					if(DebugMode)printf("FAOFF [HOLD] Disengaged\x0a");
				}else{	//If Rotational Correction is ON, Adjust Curves
					vJoystickCurveProfile = vJoystickCurveProfileBackup;	//Restore Previous Curves
					if(vJoystickCurveProfileBackup != FAOffCurve){	//Only if Previous Curve is != from FAOffCurrve preset					
						ActKey(KEYON+PULSE+EXEC("initJoystickCurves();"));
						if(DebugMode)printf("EnhancedFAOFF [HOLD] Disengaged\x0a");printf("Curve Profile Return to Default\x0a");
					}
					ActKey(KEYON+UP+FlightAssist);
					ActKey(KEYON+PULSE+EXEC("initLED(ToggleFALED, 0);"));	//Put The LED OFF
				}
			}
		}
	}
	
	//TOGGLE: Reverse Throttle
	int initToggleReverseThrottle(){
		if(Throttle[LTB]){	//If Button Is Pushed
			sRT=!sRT;	//reverse the flag status
			if(RFlightThrootleGameMode){	//TOGGLE
				ActKey(KEYON+PULSE+ReverseThrottle);
			}else{
				ActKey(KEYON+DOWN+ReverseThrottle);	//HOLD Key Down
			}
			ActKey(KEYON+PULSE+EXEC("initLED(ToggleReverseThrottleLED, 1);"));	//Put The LED ON
		}else{	//If Button Is Released
			if(!RFlightThrootleGameMode & sRT){	//HOLD Key Up
				sRT=!sRT;	//reverse the flag status
				ActKey(KEYON+UP+ReverseThrottle);
				ActKey(KEYON+PULSE+EXEC("initLED(ToggleReverseThrottleLED, 0);"));	//Put The LED OFF
			}
		}
		if(DebugMode) printf("Reverse Throttle	[%d]	[ENABLE:[1] DISABLE:[0]]\x0a", sRT );
	}
	
	//TOGGLE: Rotational Correction
	int initToggleRotationCorrection(){	
		if(!Joystick[S3]){	//Reset On The FLY S3 + SWITCH
			sRCorrection=!sRCorrection;	//reverse the flag status
			ActKey(KEYON+PULSE+RotationalCorrection);	//Push Rotational Correction Key
			if(sRCorrection) ActKey(KEYON+PULSE+EXEC("initLED(ToggleRCorrectionLED, 1);"));	//Rotational Correction is UP? Put The LED ON
			else ActKey(KEYON+PULSE+EXEC("initLED(ToggleRCorrectionLED, 0);"));	//Rotational Correction is DOWN? Put The LED OFF
		}else{	//Reset On The FLY S3 + SWITCH
			sRCorrection=!sRCorrection;	//reverse the flag status
		}
		if(DebugMode) printf("Rotation Correction	[%d]	[ENABLE:[1] DISABLE:[0]]\x0a", sRCorrection);	
	}
	
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//

	//TOGGLE: Silent Runing OFF on Fire
	int initToggleSilentRuningOFFonFire(){
		SilentRuningOFFonFire=!SilentRuningOFFonFire;	//reverse the flag status
		if(SilentRuningOFFonFire)ActKey(KEYON+PULSE+EXEC("initLED(ToggleSilentRuningonFireLED, 1);"));	//Put The LED ON
		else ActKey(KEYON+PULSE+EXEC("initLED(ToggleSilentRuningonFireLED, 0);"));	//Put The LED OFF
		if(DebugMode) printf("Silent Runing On Fire	[%d]	[ENABLE:[1] DISABLE:[0]]\x0a", SilentRuningOFFonFire);
	}

	//TOGGLE: HeatSink on Silent Runing
	int initToggleHeatSinkonSilentRuning(){
		HeatSinkonSilentRuning=!HeatSinkonSilentRuning;	//reverse the flag status
		if(HeatSinkonSilentRuning)ActKey(KEYON+PULSE+EXEC("initLED(ToggleHeatSinkonSilentRuningLED, 1);"));	//Put The LED ON
		else ActKey(KEYON+PULSE+EXEC("initLED(ToggleHeatSinkonSilentRuningLED, 0);"));	//Put The LED OFF
		if(DebugMode) printf("Heat Sink on Silent Runing	[%d]	[ENABLE:[1] DISABLE:[0]]\x0a", HeatSinkonSilentRuning);
	}	
	
	//TOGGLE: Optimal PIP Mode
	int initToggleOptimalPIPMode(){
		OptimalPIPMode=!OptimalPIPMode;	//reverse the flag status
		if(OptimalPIPMode)ActKey(KEYON+PULSE+EXEC("initLED(ToggleOptimalPIPModeLED, 1);"));	//Put The LED ON
		else ActKey(KEYON+PULSE+EXEC("initLED(ToggleOptimalPIPModeLED, 0);"));	//Put The LED OFF
		if(DebugMode) printf("Optimal PIPMode	[%d]	[ENABLE:[1] DISABLE:[0]]\x0a", OptimalPIPMode);
	}
	
	//TOGGLE: Supecruise On Throttle Mode
	int initToggleSuperCruiseMode(){
		SupecruiseOnThrottle=!SupecruiseOnThrottle;	//reverse the flag status
		if(SupecruiseOnThrottle)ActKey(KEYON+PULSE+EXEC("initLED(ToggleSuperCruiseModeLED, 1);"));	//SuperCruise On Throttle is ON? Put The LED ON
		else ActKey(KEYON+PULSE+EXEC("initLED(ToggleSuperCruiseModeLED, 0);"));	//SuperCruise On Throttle is OFF? Put The LED OFF
		if(DebugMode) printf("Supecruise On Throttle	[%d]	[ON:[1] OFF:[0]]\x0a", SupecruiseOnThrottle);
	}
	//TOGGLE: Combined Fire	
	int initToggleCombinedFire(){
		sCombinedFire=!sCombinedFire;	//reverse the flag status
		if(sCombinedFire){	//Combined Fire ON
			MapKey(&Joystick, TG2, CHAIN(PrimaryFire, SecondaryFire));	//Combine Primary & Secondary Fire on TG2
			ActKey(KEYON+PULSE+EXEC("initLED(ToggleCombinedFireLED, 1);"));	//Put The LED ON
		}else{	//Combined Fire OFF
			MapKey(&Joystick, TG2, 0);	//Separate Primary & Secondary Fire Press TG2 do Nothing
			ActKey(KEYON+PULSE+EXEC("initLED(ToggleCombinedFireLED, 0);"));	//Put The LED OFF
		}
		if(DebugMode) printf("Primary & Secondary Fire	[%d]	[COMBINED:[1] SEPARATE[0]]\x0a", sCombinedFire);
	}
	
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//

	//TOGGLE: Classified (External) 'Debug' Camera
	int initToggleCamera(){
		sCameraMode=!sCameraMode;	//reverse the flag status
		if(sSilentRuning){ActKey(KEYON+PULSE+EXEC("initToggleSilentRuning();"));}	//If Silent Runing is Engaged, Disengade it
		if(sCameraMode){	//Open The Camera Mode
			if(OptimalPIPMode){	//If Optimal Mode is Enable
				vOptimalPIPCCBackup = vOptimalPIP;	//Backup Actual PIP Mode				
				if(vOptimalPIP != 3){	// Already 4xSYS 2xENG?
					ActKey(KEYON+PULSE+EXEC("initPIPPower(SYS, ENG);"));	//4 SYS 2 ENG (3)
				}
			}
			DeferCall(1000, &ActKey, KEYON+PULSE+mClassifiedCamera);	//Call The Camera Mode Macro
			ActKey(KEYON+PULSE+EXEC("initLED(ToggleCameraLED, 1);"));	//Put The LED ON
		}else{	//Close The Camera Mode
			ActKey(KEYON+PULSE+ClassifiedCamera);	//Push The Camera Mode Key
			ActKey(KEYON+PULSE+EXEC("initLED(ToggleCameraLED, 0);"));	//Put The LED OFF
			if(OptimalPIPMode){	//If Optimal Mode is Enable
				if(vOptimalPIPCCBackup != vOptimalPIP){
					DeferCall(1000, &ActKey, KEYON+PULSE+EXEC("initRestorePIPPower(CC);"));	//Restore Previous PIP Mode
				}
			}
		}
		if(DebugMode) printf("Classified Camera	[%d]	[ON:[1] OFF:[0]]\x0a", sCameraMode);
	}

	//TOGGLE: Head Look
	int initToogleHeadLook(){																	
		if(!HMD & !TrackIR){	//Only IF No HMD & No Trackir
			if(Throttle[SC]){
				if(HeadLookGameMode){	//HeadLook [TOGGLE] Mode Ingame
					vHL=!vHL;	//reverse the flag status
					if(vHL){	//HeadLook [TOGGLE] Mode First Pulse Engage
						ActKey(KEYON+PULSE+HeadLook);						
						ActKey(KEYON+PULSE+EXEC("initLED(ToogleHeadLookLED, 1);"));	//Put The LED ON
						if(DebugMode) printf("HeadLook [Toggle] Engaged\x0a");
					}else{	//HeadLook [TOGGLE] Mode Second Pulse DisEngage				
						ActKey(KEYON+PULSE+HeadLook);
						ActKey(KEYON+PULSE+EXEC("initLED(ToogleHeadLookLED, 0);"));	//Put The LED OFF
						if(DebugMode) printf("HeadLook [Toggle] Disengaged\x0a");
					}
				}else{	//HeadLook [HOLD] Mode Ingame Engage
					ActKey(KEYON+DOWN+HeadLook);
					ActKey(KEYON+PULSE+EXEC("initLED(ToogleHeadLookLED, 1);"));	//Put The LED ON
					if(DebugMode)printf("HeadLook [HOLD] Engaged\x0a");
				}
			}else{	//If Button Is Released
				if(!HeadLookGameMode){	//HeadLook [HOLD] Mode Ingame DisEngage
					ActKey(KEYON+UP+HeadLook);
					ActKey(KEYON+PULSE+EXEC("initLED(ToogleHeadLookLED, 0);"));	//Put The LED OFF
					if(DebugMode)printf("HeadLook [HOLD] DisEngaged\x0a");
				}
			}
		}
	}

	//TOGGLE: GameMenu
	int initToggleGameMenu(){
		vGameMenu=!vGameMenu;	//reverse the flag status
		if(sSilentRuning)ActKey(KEYON+PULSE+EXEC("initToggleSilentRuning();"));	//If Silent Runing is Engaged, Disengade it
		if(vGameMenu){	//Open The Game Menu
			if(OptimalPIPMode){	//If Optimal Mode is Enable
				vOptimalPIPGMBackup = vOptimalPIP;	//Backup Actual PIP Mode			
				if(vOptimalPIP != 3){	// Already 4xSYS 2xENG?
					ActKey(KEYON+PULSE+EXEC("initPIPPower(SYS, ENG);"));	//4 SYS 2 ENG (3)
				}
			}
			ActKey(KEYON+PULSE+SetSpeed0);	//Push Set Speed To 0 Key
			ActKey(KEYON+PULSE+EXEC("initLED(ToggleGameMenuLED, 1);"));	//Put The LED ON
		}else{	//Close The Game Menu
			if(OptimalPIPMode){	//If Optimal Mode is Enable
				if(vOptimalPIPGMBackup != vOptimalPIP){
					DeferCall(6000, &ActKey, KEYON+PULSE+EXEC("initRestorePIPPower(GM);"));	//Restore Previous PIP Mode After 3s
				}
			}
			ActKey(KEYON+PULSE+EXEC("initLED(ToggleGameMenuLED, 0);"));	//Put The LED OFF
		}		
		DeferCall(3000, &ActKey, KEYON+PULSE+GameMenu);	//Push Game Menu Key After 3s
		if(DebugMode) printf("Game Menu	[%d]	[ENABLE:[1] DISABLE:[0]]\x0a", vGameMenu);
	}	
	
	//TOGGLE: Menu and LED OFF on Idle (Check PERSONAL SETTINGS in Settings File)	
	int initToggleIDLEonThrottle(){
		if(!Joystick[S3]){	//Reset On The FLY S3 + SWITCH
			if(Throttle[IDLELON]) sIDLE = 1;	//Throttle position is IDLE State =1
			else sIDLE = 0;	//Throttle position is !IDLE State =0
			if(GameMenuOnIDLE)ActKey(KEYON+PULSE+EXEC("initGameMenu();"));	//If GameMenu on IDLE Option is 1, Launch Game Menu
			//if(GameMenuOnIDLE)ActKey(KEYON+PULSE+GameMenu);				//If GameMenu on IDLE Option is 1, Launch Game Menu Use this one If the previous cause BUG (Client delay to open Game Menu vary)
			if(sIDLE){	//If Throttle position is IDLE State =1
				ActKey(PULSE+KEYON+LED(&Throttle, LED_INTENSITY, ThrottleLEDOnIDLE));
				if(ThrottleLEDOnIDLE!=0)ActKey(KEYON+PULSE+EXEC("initLED(ToggleIDLEonThrottleLED, 1);"));	//Put The LED ON Only if Throttle Backlight on IDLE is ON (If Off We don't see LED :) )
			}else{	//Throttle position is !IDLE State =0
				ActKey(PULSE+KEYON+LED(&Throttle, LED_INTENSITY, vThrottleLightBackup));
				if(ThrottleLEDOnIDLE!=0)ActKey(KEYON+PULSE+EXEC("initLED(ToggleIDLEonThrottleLED, 0);"));	//Put The LED OFF Only if Throttle Backlight on IDLE is ON (If Off We don't see LED :) )
			}
			if(DebugMode) printf("IDLE On Throttle	[%d]	[ENABLE:[1] DISABLE:[0]]\x0a", sIDLE);
		}
	}
	
	//TOGGLE: PTT/PTP
	int initTogglePTTPTP(){
		sPTTMode=!sPTTMode;	//reverse the flag status
		if(sPTTMode)ActKey(KEYON+PULSE+EXEC("initLED(TogglePTTModeLED, 1);"));	//Put The LED ON
		else ActKey(KEYON+PULSE+EXEC("initLED(TogglePTTModeLED, 0);"));	//Put The LED OFF
		if(DebugMode) printf("PTTMode Change	[%d]	[HOLD:[0] TOGGLE:[1]]\x0a", sPTTMode);
	}
	
	//TOGGLE: External/Internal Voice
	int initTogglePTTMode(){
		sPTTState=!sPTTState;	//reverse the flag status
		if(sPTTState)ActKey(KEYON+PULSE+EXEC("initLED(TogglePTTLED, 1);"));	//Put The LED ON
		else ActKey(KEYON+PULSE+EXEC("initLED(TogglePTTLED, 0);"));	//Put The LED OFF
		if(DebugMode) printf("Mic Change		[%d]	[External:[0]Internal:[1]]\x0a", sPTTState);
	}
	
	//TOGGLE: StopFire When Retract Hardpoints
	int initToggleStopFireRetractHardpoints(){
		StopFireRetractHardpoints=!StopFireRetractHardpoints;
		if(StopFireRetractHardpoints)ActKey(KEYON+PULSE+EXEC("initLED(ToggleStopFireRetractHardpointsLED, 1);"));	//Put The LED ON
		else ActKey(KEYON+PULSE+EXEC("initLED(ToggleStopFireRetractHardpointsLED, 0);"));	//Put The LED OFF
		if(DebugMode) printf("Retract HP on Fire	[%d]	[ENABLE:[1] DISABLE:[0]]\x0a", StopFireRetractHardpoints);
	}
	
	//TOGGLE: SecureRetract
	int initToggleSecureRetract(){
		SecureRetract=!SecureRetract;
		if(SecureRetract)ActKey(KEYON+PULSE+EXEC("initLED(ToggleSecureRetractLED, 1);"));	//Put The LED ON
		else ActKey(KEYON+PULSE+EXEC("initLED(ToggleSecureRetractLED, 0);"));	//Put The LED OFF
		if(DebugMode) printf("SecureRetract		[%d]	[ENABLE:[1] DISABLE:[0]]\x0a", SecureRetract);
	}	
	
	//TOGGLE: Voice Attack Mic
	int initToggleVoiceAttackMic(){
		if(VoiceAttack){
			sVoiceAttack=!sVoiceAttack;	//reverse the flag status
			ActKey(KEYON+PULSE+ToggleVoiceAttackMic);
			if(sVoiceAttack)ActKey(KEYON+PULSE+EXEC("initLED(ToggleVALED, 1);"));	//Put The LED ON
			else ActKey(KEYON+PULSE+EXEC("initLED(ToggleVALED, 0);"));	//Put The LED OFF
			if(DebugMode) printf("Voice Attack Mic	[%d]	[MUTE:[1] UNMUTE:[0]]\x0a", sVoiceAttack);
		}
	}
	
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
//	FUNCTIONS																																					//
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//		
	
	//FUNCTION FPS & CONNECTION STATUS
	int initFPSCONNECTION(){
		ActKey(KEYON+PULSE+ShowFramerate);
		ActKey(KEYON+PULSE+ShowConnectionStatus);
		if(DebugMode)printf("FPS & CONNECTION STATUS\x0a");
	}
	
	//FUNCTION: Head Center
	int initHeadCenter(){
		if(HMD){ActKey(KEYON+PULSE+HMDCenter); if(DebugMode)printf("HMD Center\x0a");}
		else if(TrackIR){ActKey(KEYON+PULSE+TrackIRCenter); if(DebugMode)printf("TrackIR Center\x0a");}
		else{ActKey(KEYON+PULSE+UIFocus); if(DebugMode)printf("UI Focus\x0a");}
	}
	
	//FUNCTION: Voice PTT
	int initVoicePTT(){
		if(sPTTState)vPTT = InternalVoiceCommsPTT;	//External Mic
		else if(!sPTTState)vPTT = ExternalVoiceCommsPTT;	//Internal Mic
		if(Throttle[MSP]){
			vVoicePTT=!vVoicePTT;	//reverse the flag status
			if(sPTTMode){	//TOGGLE
				vVoice=!vVoice;	//reverse the flag status
				ActKey(KEYON+PULSE+vPTT);
				if(vVoice){	//Talk [TOGGLE]
					ActKey(KEYON+PULSE+EXEC("initLED(ToggleVoicePTTLED, 1);"));	//Put The LED ON
				}else{	//Silence [TOGGLE}	
					ActKey(KEYON+PULSE+EXEC("initLED(ToggleVoicePTTLED, 0);"));	//Put The LED OFF
				}
				if(DebugMode) printf("Mic Toggle [%d] [Actived[1] DesActived[0] / PTT [%d] [External:[0]Internal:[1]] / Mode [%d] [HOLD:[0] TOGGLE:[1]]\x0a", vVoicePTT, sPTTState, sPTTMode);
			}else{	//Talk [HOLD]
				ActKey(KEYON+DOWN+vPTT);
				ActKey(KEYON+PULSE+EXEC("initLED(ToggleVoicePTTLED, 1);"));	//Put The LED ON
			}
		}
		if(!Throttle[MSP] & !sPTTMode){	//Silence [HOLD]
			vVoicePTT=!vVoicePTT;	//reverse the flag status
			ActKey(KEYON+UP+vPTT);
			ActKey(KEYON+PULSE+EXEC("initLED(ToggleVoicePTTLED, 0);"));	//Put The LED OFF
		}
		if(DebugMode & !sPTTMode) printf("Mic Toggle [%d] [Actived[1] DesActived[0] / PTT [%d] [External:[0]Internal:[1]] / Mode [%d] PUSH:[0] TOGGLE:[1]]\x0a", vVoicePTT, sPTTState, sPTTMode);
	}
	
	//FUNCTION: Toggle LED	requested, Params = Toggle Name LED, ON[1] or OFF[0] (ex:	initLED(ToggleLandingGearLED, 1)	Will up the LG LED if ToggleLandingGearLED is Define in setting (!=0))
	int initLED(int l = 0, int LEDONOFF =0){
		if(LEDONOFF == 1 & l!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+l));	//LED ON
		if(LEDONOFF == 0 & l!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-l));	//LED OFF
	}
	
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
//	GAMES FUNCTIONS																																				//
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//

	//FUNCTION: Init Fire
	int initFire(){
		if(Joystick[TG1] | Joystick[S2]){	//PRESS THE TG1 or S2 BUTTON	
			if(SilentRuningOFFonFire & sSilentRuning){
				if(!vSLonFire){
					vSLonFire=!vSLonFire;	//reverse the flag status
					vSilentRuningBackup = sSilentRuning;	//Backup Actual Silent Runing State
					ActKey(KEYON+PULSE+EXEC("initToggleSilentRuning();"));
				}
			}
			if(HardPointsonFireGameMode & !sHardPoints){ActKey(KEYON+PULSE+EXEC("initToggleHardpoints();"));}
			if(OptimalPIPMode){	//If Optimal Mode is Enable
				vOptimalPIPFireBackup = vOptimalPIP;	//Backup Actual PIP Mode
				if(vOptimalPIP != 6){	// Already 4xWEP 2xSYS?
					ActKey(KEYON+PULSE+EXEC("initPIPPower(WEP,SYS);"));	//4 WEP 2 SYS (6)
				}
			}			
			if(Joystick[TG1]){ActKey(KEYON+DOWN+PrimaryFire);}
			if(Joystick[S2]){ActKey(KEYON+DOWN+SecondaryFire);}
			//if(DebugMode)printf("vSLonFire [%d]\x0a", vSLonFire);
		}else{				//RELEASE THE TG1 or S2 BUTTON
			if(!Joystick[TG1]){ActKey(KEYON+UP+PrimaryFire);}
			if(!Joystick[S2]){ActKey(KEYON+UP+SecondaryFire);}
			if(OptimalPIPMode & !Joystick[TG1] & !Joystick[S2]){	//If Optimal Mode is Enable
				if(vOptimalPIPFireBackup != vOptimalPIP){
					ActKey(KEYON+PULSE+EXEC("initRestorePIPPower(FIRE);"));	//Restore Previous PIP Mode				
				}
			}			
			if(HardPointsonFireGameMode & StopFireRetractHardpoints & sHardPoints & !Joystick[S2] & !Joystick[TG1]){ActKey(KEYON+PULSE+EXEC("initToggleHardpoints();"));}
			if(vSilentRuningBackup!=0 & !Joystick[S2] & !Joystick[TG1]){
				vSilentRuningBackup = 0;
				ActKey(KEYON+PULSE+EXEC("initToggleSilentRuning();"));	//Restore Silent Runing State
			}
			if(SilentRuningOFFonFire & sSilentRuning & vSLonFire & !Joystick[S2] & !Joystick[TG1]){
				vSLonFire=!vSLonFire;	//reverse the flag status
			}
			//if(DebugMode)printf("vSLonFire [%d]\x0a", vSLonFire);
		}
	}
	
	//FUNCTION: Jettison All Cargo	
	int initJettisonCargo(){																
		if(Throttle[APUON]){
			if(sCargo){																		
				ActKey(KEYON+PULSE+JettisonAllCargo);
				if(DebugMode) printf("Jettison All Cargo\x0a");
			}else{
				if(DebugMode) printf("Jettison Need Cargo Scoop Open\x0a");
			}
		}
	}

	//FUNCTION: Init Secure Retract
	int initSecureRectract(){
		vSecureEscapeFight=!vSecureEscapeFight;	//reverse the flag status
		if(sHardPoints) ActKey(KEYON+PULSE+EXEC("initToggleHardpoints();"));
		if(sGears) ActKey(KEYON+PULSE+EXEC("initToggleLandingGear();"));
		if(sCargo) ActKey(KEYON+PULSE+EXEC("initToggleCargoScoop();"));
		vSecureEscapeFight=!vSecureEscapeFight;
	}

	//FUNCTION: Init Supercruise
	int initSuperCruise(){
		if(SecureRetract) ActKey(KEYON+PULSE+EXEC("initSecureRectract();"));
		ActKey(KEYON+PULSE+Supercruise);
		if(DebugMode) printf("Engage SuperCruise\x0a");
	}
	
	//FUNCTION: Init FrameShiftDrive
	int initFrameShiftDrive(){
		if(SecureRetract) ActKey(KEYON+PULSE+EXEC("initSecureRectract();"));
		ActKey(KEYON+PULSE+FrameShiftDrive);
		if(DebugMode) printf("Engage FSD\x0a");
	}
	
	//FUNCTION: SystemJump
	int initSystemJump(){
		if(SecureRetract) ActKey(KEYON+PULSE+EXEC("initSecureRectract();"));
		ActKey(KEYON+PULSE+mSystemJump);
		if(DebugMode) printf("Engage System Jump\x0a");
	}
	
	//FUNCTION: Use Supercruise while boosting if Throttle is 100%
	int initThrottleBoost(){
		if(SupecruiseOnThrottle & AxisVal(Throttle[THR_RIGHT], &axdata) >= 32767){	//Throttle All the Way Up & SupecruiseOnThrottle is Actived?
				if(SecureRetract){ActKey(KEYON+PULSE+EXEC("initSecureRectract();"));}
				ActKey(KEYON+PULSE+Supercruise);
				if(DebugMode) printf("SuperCruise On Throttle Engaged\x0a");
		}else{
			ActKey(KEYON+PULSE+EngineBoost);
			if(DebugMode) printf("Engine Boost\x0a");
		}
	}

	//FUNCTION: Escape Fight
	int initEscapeFight(){
		if(SecureRetract){ActKey(KEYON+PULSE+EXEC("initSecureRectract();"));}
		if(!sSilentRuning){ActKey(KEYON+PULSE+EXEC("initToggleSilentRuning();"));}	//If Silent Running is Disable, Enable it
		if(OptimalPIPMode){	//If Optimal Mode is Enable
			vOptimalPIPEFBackup = vOptimalPIP;	//Backup Actual PIP Mode
			if(vOptimalPIP != 1){	// Already 4xENG 2xSYS?			
				ActKey(KEYON+PULSE+EXEC("initPIPPower(ENG, SYS);"));	//4 ENG	2 SYS (1)
			}
			DeferCall(1500, &ActKey, KEYON+PULSE+EXEC("initPIPPower(SYS, ENG);"));	//4 SYS 2 ENG (3)
			if(vOptimalPIPEFBackup != vOptimalPIP){
				DeferCall(10000, &ActKey, KEYON+PULSE+EXEC("initRestorePIPPower(EF);"));	//Restore Previous PIP Mode
			}
		}
		ActKey(KEYON+PULSE+mEscapeFight);
		if(sSilentRuning){DeferCall(4000, &ActKey, KEYON+PULSE+EXEC("initToggleSilentRuning();"));}		//Disable Silent Runing previouly Enable
		if(DebugMode) printf("Escape Mode Engaged : CHECK IF GEARS AND CARGO STATE IS OK (SWITCH CS and LG)\x0a");
	}
	
	//FUNCTION: Request Docking
	int initRCDocking(){
		if(DebugMode) printf("Docking Initialisation\x0a");
		if(SecureRetract){ActKey(KEYON+PULSE+EXEC("initSecureRectract();"));}
		ActKey(KEYON+PULSE+mRequestCancelDock);
		if(OptimalPIPMode){	//If Optimal Mode is Enable
			DeferCall(3000, &ActKey, KEYON+PULSE+EXEC("initPIPPower(SYS, ENG);"));	//4 SYS 2 ENG (3)
		}
	}

	//FUNCTION: Autopilot Engage / Disengage Key
	int initEngageAPkey(){
		if (Throttle[APPAT]) ActKey(KEYON+PULSE+EXEC("initRCDocking();"));
		else if (Throttle[APAH]) ActKey(KEYON+PULSE+EXEC("initEscapeFight();"));
		else if (Throttle[APALT] & !Joystick[S3]) ActKey(KEYON+PULSE+EXEC("initSystemJump();"));
		else if (Throttle[APALT] & Joystick[S3]) ActKey(KEYON+PULSE+CancelFSD);
	}

//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
//	PIP MANAGEMENT FUNCTIONS																																	//
//																																								//
//		initPIPPower(x,y,z)	Params = SYS, ENG, WEP, MID																											//
//			x gets 4 PIPs, y gets 2 PIPs, if z = MID get 50/50 of x and y (3x 3y)																				//
//			If only x, balanced 1 PIP on each 2ndary power																										//
//			If no params, balances power.																														//
//																																								//
//		initRestorePIPPower(j)	Params = HarPoints (HP) Or FIRE (Fire) OR EF (Escape Fight) OR GM (Game Menu) OR CC (Classified Camera)							//
//																																								//
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
	
	//PIP Management
	int initPIPPower(int x=0, int y=0, int z=0){

		// Map out PIPs
		if(x == 0) PIPfull = 0;
		else if(x == SYS) PIPfull = PULSE+ PowerSys;
		else if(x == ENG) PIPfull = PULSE+ PowerEng;
		else if(x == WEP) PIPfull = PULSE+ PowerWep;
	
		if(y == 0) PIPhalf = 0;
		else if(y == SYS) PIPhalf = PULSE+ PowerSys;
		else if(y == ENG) PIPhalf = PULSE+ PowerEng;
		else if(y == WEP) PIPhalf = PULSE+ PowerWep;

		if(z == 0 & z != MID) PIPMid = 0;
		else if(z == MID) PIPMid = PIPhalf;
		
		// Send PIPS
		ActKey(KEYON+ CHAIN(PULSE+ BalancePower, D(PIPPulseDelay),PIPfull, D(PIPPulseDelay),PIPhalf, D(PIPPulseDelay),PIPfull, D(PIPPulseDelay),PIPfull, D(PIPPulseDelay),PIPMid));
		
		// Save the PIPS for Automatique PIP MODE RESET (OptimalPIPMode in Settings File)
		if(OptimalPIPMode){
			if(x == 0 & y == 0 & z == 0){if(vOptimalPIP != 0) vOptimalPIP = 0;}		//2 SYS 2 ENG 2 WEP (0)
			else if(z != MID | z == 0){
				if(y != 0){
					if(y == SYS){
						if(x == ENG){if(vOptimalPIP != 1) vOptimalPIP = 1;}			//4 ENG	2 SYS (1)
						else if(x == WEP){if(vOptimalPIP != 6) vOptimalPIP = 6;}	//4 WEP 2 SYS (6)
					}
					else if(y == ENG){
						if(x == SYS){if(vOptimalPIP != 3) vOptimalPIP = 3;}			//4 SYS 2 ENG (3)
						else if(x == WEP){if(vOptimalPIP != 5) vOptimalPIP = 5;}	//4 WEP 2 ENG (5)
					}
					else if(y == WEP){
						if(x == SYS){if(vOptimalPIP != 4) vOptimalPIP = 4;}			//4 SYS 2 WEP (4)
						else if(x == ENG){if(vOptimalPIP != 2) vOptimalPIP = 2;}	//4 ENG 2 WEP (2)
					}
				}
				else if(y ==0){
					if(x == SYS){if(vOptimalPIP != 10) vOptimalPIP = 10;}			//4 SYS 1 ENG 1 WEP (10)
					else if(x == ENG){if(vOptimalPIP != 11) vOptimalPIP = 11;}		//4 ENG 1 SYS 1 WEP (11)
					else if(x == WEP){if(vOptimalPIP != 12) vOptimalPIP = 12;}		//4 WEP 1 SYS 1 ENG (12)
				}
			}
			else if(z == MID){	
				if(y != 0){
					if(y == SYS & x == ENG | y == ENG & x == SYS){if(vOptimalPIP != 7) vOptimalPIP = 7;}		//3 SYS 3 ENG (7)
					else if(y == ENG & x == WEP | y == WEP & x == ENG){if(vOptimalPIP != 8) vOptimalPIP = 8;}	//3 ENG 3 WEP (8)
					else if(y == SYS | x == WEP | y == WEP | x == SYS){if(vOptimalPIP != 9) vOptimalPIP = 9;}	//3 SYS 3 WEP (9)
				}
			}
			if(DebugMode) printf("Initialising PIP Commands	[%d]\x0a", vOptimalPIP);
		}
	}
	
	//PIP Restore Management
	int initRestorePIPPower(int j=0){
		
		//Check What PIP to Restore, HarPoints (HP) Or FIRE (Fire) OR EF (Escape Fight) OR GM (Game Menu) OR CC (Classified Camera)
		if(j == FIRE) PIPRestore = vOptimalPIPFireBackup;	//Weapon Fire
		else if(j == HP) PIPRestore = vOptimalPIPHPBackup;	//HardPoints
		else if(j == EF) PIPRestore = vOptimalPIPEFBackup;	//Escape Fight
		else if(j == GM) PIPRestore = vOptimalPIPGMBackup;	//Game Menu
		else if(j == CC) PIPRestore = vOptimalPIPCCBackup;	//Classified Camera

		// Send Good Backup PIPS
		if(DebugMode)printf("Reset PIP Mode--------------->\x0a");
		if(PIPRestore == 0)ActKey(KEYON+PULSE+EXEC("initPIPPower();"));				//If no Previous PIP Mode selected Balance Power
		else if(PIPRestore == 1)ActKey(KEYON+PULSE+EXEC("initPIPPower(ENG,SYS);"));		//4 ENG	2 SYS (1)
		else if(PIPRestore == 2)ActKey(KEYON+PULSE+EXEC("initPIPPower(ENG,WEP);"));		//4 ENG 2 WEP (2)
		else if(PIPRestore == 3)ActKey(KEYON+PULSE+EXEC("initPIPPower(SYS,ENG);"));		//4 SYS 2 ENG (3)
		else if(PIPRestore == 4)ActKey(KEYON+PULSE+EXEC("initPIPPower(SYS,WEP);"));		//4 SYS 2 WEP (4)
		else if(PIPRestore == 5)ActKey(KEYON+PULSE+EXEC("initPIPPower(WEP,ENG);"));		//4 WEP 2 ENG (5)
		else if(PIPRestore == 6)ActKey(KEYON+PULSE+EXEC("initPIPPower(WEP,SYS);"));		//4 WEP 2 SYS (6)
		else if(PIPRestore == 7)ActKey(KEYON+PULSE+EXEC("initPIPPower(SYS,ENG,MID);"));	//3 SYS 3 ENG (7)
		else if(PIPRestore == 8)ActKey(KEYON+PULSE+EXEC("initPIPPower(ENG,WEP,MID);"));	//3 ENG 3 WEP (8)
		else if(PIPRestore == 9)ActKey(KEYON+PULSE+EXEC("initPIPPower(SYS,WEP,MID);"));	//3 SYS 3 WEP (9)	
		else if(PIPRestore == 10)ActKey(KEYON+PULSE+EXEC("initPIPPower(SYS);"));			//4 SYS 1 ENG 1 WEP (10)
		else if(PIPRestore == 11)ActKey(KEYON+PULSE+EXEC("initPIPPower(ENG);"));			//4 ENG 1 SYS 1 WEP (11)
		else if(PIPRestore == 12)ActKey(KEYON+PULSE+EXEC("initPIPPower(WEP);"));			//4 WEP 1 SYS 1 ENG (12)
	}